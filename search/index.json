[{"content":"在最近两个月的时候，大约以一天一集的速度看完了k-on 第一部、第二部、电影。\n见anilist观影记录：foth0626\n轻音给人的是一种轻松的，哀而不伤的气氛，没有什么轰轰烈烈，要死要活，赌咒发誓的大事，它描绘的就是在平凡的高中里一个普通的社团的摸鱼生活。它是小的，具体化的，生活化的。片中的角色的烦恼也是每个普普通通的少女会面对的烦恼，是上学时忘记夹发卡，考试有可能不及格，高中升学应该报考哪座大学，毕业后见不到关系很好的学妹。它的快乐也是一样的，和朋友一起喝茶，一起旅行，一起参加校园祭，一起逛商场，养宠物。\n最终呈现出的整部作品的气质是亲切，平和，宁静的。我相信这部作品是在创作者的爱中诞生的。\n作品对于五人的描述是细腻的，从一件件日常的小事堆砌出角色的形象，从这个角度来看，轻音少女是一部带有音乐元素的日常番，对于日常的切面构成了整部番剧的叙事。从几次乐队的演奏选择也可以看出：对于排练，校园祭的演出，在英国的演出，大多只是开头和尾奏，整部作品唯一一次完整的乐曲是在电影的末尾，四人一起演唱《相遇天使》。但这次演出是服务于描绘五人的友情的。\n总的来说，值得推荐的一部番剧，独属于慢节奏的舒缓和少女们的美好。\n","date":"2025-11-11T14:33:26+08:00","permalink":"https://foth0626.github.io/article/bangumi/k-on/","title":"轻音少女 简评"},{"content":"shuggoth hnahh ahor Y\u0026rsquo; ai 最近感觉自己的理智蒸发的非常离谱，我在思考自己是否已经成为了某种意义上披着人皮的异种生物。我思考人在世界上的位置，毕竟我在约莫初中的时候接触了跑团，还品尝了沙耶之歌这种作品，伟大的三倍的光辉的神明存在于世上，人类以鲁莽的自信航行于晦暗的无边的迷失的亵渎的海上，试图呼吸着氮气般的真相。我的位置在人世的何处？我不合群但也不离群，我常在人前熟络后默默离场，享受着自我的孤独，我享受三个自我之间的辩论。我品尝着离群索居的快乐。我观看动画，享受不同时域不同规则下的美妙故事；我品味书籍，同超越时间之人对话，思考着伟大存在的伟大；我玩游戏，也云游戏，我思考这个时代的新媒介如何成为伟大，如何致敬伟大，如何学会敬畏。我的现实是沉重的引力，我的精神却狂放不羁地交织着不同的臆想。\n我时常觉得我是一名KP，我知晓人类的光辉，见证着人类的丑恶，我知道那些邪异生物的降生，那些触手和蠕虫蠢动的黑暗角落。我见过纯真的怪物，也见过孽毒的人类。我既不属于人类，也不选择怪物。我寻欢作乐，我是乐子。 我观察，我记住，我不语。\n怪物与人的关系究竟是什么呢。。。\nH1标题由拉莱耶语生成器生成\n","date":"2025-10-19T21:44:52+08:00","permalink":"https://foth0626.github.io/article/miscellany-2025-10-19/","title":"杂谈：2025-10-19"},{"content":" 本系列文章基于《Pro Git》一书，作为本人学习记录\n获取Git仓库 将一个没有版本控制的本地目录转换为Git仓库 从服务器克隆(clone)一个已存在的仓库 从本地目录初始化 首先，cd /path/to/your/project ，然后执行 git init ，这会创建 .git 的一个子目录。\n如果此时这个目录非空，那么应该开始追踪并进行初始提交。 使用 git add 指定需要追踪的文件，然后 git commit\n1 2 3 git add *.cpp git add LICENSE git commit -m \u0026#39;inital project version\u0026#39; 克隆已有仓库 从服务器上克隆已有的数据（包括所有的历史数据） git clone https://github.com/libgit2/libgit2 这会在当前目录创建一个libgit2的目录，并创建 .git 目录，将数据存放进去。\n如果你想要使用自定义的目录名那么\ngit clone https://github.com/libgit2/libgit2 mylibgit\n除了使用https，git也可以使用git:// 或者 ssh 协议。\n记录更新到仓库 通常，你会对文件做些修改，并在完成修改后提交到仓库以记录下修改。\n工作目录下的所有文件只存在两种状态： 已跟踪 和 未跟踪 。 已跟踪的文件就是那些已经被纳入版本控制的文件，它们的状态是未修改，已修改或已暂存。\n所以有如下关系:\n未跟踪文件被添加到版本控制后，会进入已暂存状态。 未修改文件在修改后变为已修改文件，移除文件变为未跟踪 。 已修改文件在暂存后变为已暂存文件 暂存文件在commit变为未修改文件 检查文件状态 使用 git status 查看文件处于什么状态。对于刚克隆的仓库，应该是\u0026quot;everything is up to date\u0026quot; 的。\n新建一个README文件，再使用git status可以看到输出结果多了Untracked Files，包含了README文件\n1 2 3 4 On branch master Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) README 跟踪新文件 使用git add FILENAME 开始跟踪文件，此时再git status 则发现 Changes to be committed 这表明文件处于 已暂存 状态。\ngit add 接受文件或者目录，如果是目录则会递归跟踪该目录下的所有文件。\n1 2 3 4 On branch master Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: README 暂存已修改文件 假设现在有一个文件 aaa.md ，且已被跟踪。你对它进行了修改，此时运行git status 则会有：\n1 2 3 4 5 6 7 On branch master Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: aaa.md no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) Changes not staged for commit 表明已跟踪文件发生了变化，但没有暂存。如果需要暂存这次更新，则运行git add ，当这个命令接受的文件是已跟踪文件，则功能变化为将已跟踪的文件放入暂存区。将这个命令理解为“将内容添加到下一次的提交中”是比较合适的说法。\n1 2 3 4 On branch master Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: aaa.md 注意：如果你现在对aaa.md进行修改，再运行git status\n1 2 3 4 5 6 7 8 9 10 On branch master Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: README modified: aaa.md Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: aaa.md 现在aaa.md 同时存在暂存区和非暂存区，这是因为Git记录的是你最后一次git add 的文件版本，所以如果你需要提交最新文件那么，你得再次git add\n1 2 3 4 5 On branch master Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: README modified: aaa.md 状态简略输出 使用git status -s 或者 git status --short 可以获得一个更为紧凑的输出\n1 2 A README M aaa.md 事实上，输出类型共有三种分别为?,A,M,分别指代未跟踪，新添加，已修改。 不仅如此，输出结果事实上有两栏，我现在再对aaa.md 修改。\n1 2 A README MM aaa.md 左栏代表着暂存区状态，右栏表示工作区状态。\n所以MM表明文件修改有一部分是暂存的，还有一部分没有被暂存。\n忽略文件（.gitignore) 有些文件我们不希望它进入Git的管理中，我们也不希望它们出现在未跟踪列表。比如编译缓存，日志等。此时我们可以创建.gitignore 文件。下面是一个示例\n1 2 *.[oa] *~ 第一行表明忽略所有 .o 和 .a 文件。第二行表明 忽略所有最后以~结尾的文件。 .gitginore 的规则如下：\n所有空行或 以# 开头的行会被忽略 使用glob模式匹配，并且递归的应用于整个工作区中。 匹配模式可以使用/ 开头防止递归（使用/temp这种写法，只会匹配根目录的temp文件夹，而不会匹配其他目录里的文件夹，如果使用temp/则会匹配所有temp文件夹） 匹配模式可以使用/ 结尾指定目录（如build/） 一些符合匹配忽略规则的，但是我们希望加入版本管理的文件，使用! 取反。 其中glob模式是指：\n使用*作为通配符，匹配任意多个任意字符。 使用[]匹配方括号内任意一个字符。如[abc]可以为a,b,c任意一个字符 ？ 匹配任意一个字符 使用**匹配任意中间目录，如src/**/*.js则会匹配所有子文件的js文件 查看已暂存和未暂存的修改 git status只能查看哪些文件有改变，但是不能查看具体修改了些什么，此时可以使用git diff，git diff能通过文件补丁的方式具体显示哪些行发生了变化。这个指令展示的是工作区和暂存区之间的差异，也就是修改后没有暂存的内容。\n如果想要查看已暂存的文件和最后一次提交（commit）的区别，那么使用git diff --staged 或者 git diff --cached\n提交更新（commit） 在提交之前，请确保没有已经修改的文件却没有git add过，否则提交时不会记录这些文件的变化。所以使用 git status 确保所有文件已暂存。 使用 git commit 指令提交更新，这是会启用你的文本编辑器来输入提交说明。\ngit commit 会默认使用注释格式显示 git status 的内容，这有助你确认修改内容，如果你希望查看 git diff 的输出内容，那么commit时添加额外的参数 -v 。\n除此之外，如果你希望直接在命令里输入提交说明，那么，使用参数 -m 并附带消息，如 git commit -m \u0026quot;God Bless You!\u0026quot;\n跳过暂存区 如果你不希望添加暂存并提交，这样略繁琐的步骤，那么，直接使用参数 -a 可以直接把所有已跟踪文件暂存并提交\ngit commit -a -m \u0026quot;add: new feature\u0026quot;\n移除文件 如果想要从Git中移除文件，那么就也得从暂存区中移除并提交。如果直接在本地手动删除文件，那么会导致这个文件仍然记录在未暂存区域。需要使用 git rm FILENAME 来移除一个未修改文件。\n如果一个文件已经保留在暂存区中，或者处于已修改的文件，那么需要使用 git rm -f \u0026lt;filename\u0026gt; ，这是为了确保尚未添加到快照中的文件不被误删除。或者使用 git rm --cached \u0026lt;filename\u0026gt; 指令，这会使文件在Git仓库中被删除，但是保留本地文件，这是为了处理误添加了一堆不想跟踪的文件进暂存区的情况 ，如没有使用 .gitignore 导致的一堆编译文件。\n当然 git rm 指令后也可以使用glob模式匹配文件，如 git rm log/\\*.log 注意，\\是用于展开通配符 * 的。\n移动文件 在Git中对文件改名，使用 git mv file_from file_to 这等价于\n1 2 3 mv file_from file_to git rm file_from git add file_to 查看提交历史 使用 git log 指令，可以查看所有提交，默认最近的更新在最上方，并会给出每次提交的校验，作者的姓名和邮箱，提交时间，提交说明。\ngit log 有许多选项，其中 -p 或者 --patch ，这会按照补丁（类似于git diff)的格式输出，也可以使用 -2 这类命令限制一次输出的日志数量。--stat 会按照简略形式表示更改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 commit ded2ebf137ddc0b1f60e09fe3c96a3b88f491033 (HEAD -\u0026gt; master) Author: foth \u0026lt;fothli0626@gmail.com\u0026gt; Date: Sat Oct 18 19:34:56 2025 +0800 God Bless You README | 1 + aaa.md | 2 ++ 2 files changed, 3 insertions(+) commit 42a782e56593d75b86ef8f3d52309dc09ed66406 Author: foth \u0026lt;fothli0626@gmail.com\u0026gt; Date: Sat Oct 18 16:25:11 2025 +0800 aaa.md aaa.md | 1 + 1 file changed, 1 insertion(+) 格式参数 使用 pretty 参数可以改变提交显示的格式。有 oneline short full fuller 等内置参数，还可以使用 pretty=format\u0026quot;THIS IS CUSTOM FORMAT\u0026quot; 自定义输出格式。关于format具体有哪些格式和参数，这里不做介绍。\n--graph 能够是用ascii字符画形式，可视化的展现仓库的提交历史（俗称画电路板（笑）。）\n时间参数 上面我们提到可以展示任意条数量记录的 -\u0026lt;n\u0026gt; 参数，也可以使用 --since 或者 --until 这种形式 --since=2.weeks 表示最近两周的提交，这类格式不仅可以使用绝对日期，也可以使用相对时间如 \u0026quot;2 years 1 day 3 minutes ago\u0026quot;\n过滤与搜索 使用 --author , --commiter --grep 可以搜索作者，提交者和提交信息中的关键词。\n另一个有用的过滤条件是参数 -S ，这个参数需要一个字符串参数，这会搜索出所有修改的文件内容中包含该字符串的提交。比如你想寻找添加或者删除了某一个函数的调用的提交那么可以使用 git log -S \u0026quot;function_name\u0026quot; 。\n最后，如果想要搜索某个有关特定文件的提交，可以使用 -- path/to/file 这个参数，注意，这个参数必须为 git log 的最后一个参数。 不过注意，当有多个参数搜索时，任一条件满足即会打印，加上 --all-match 参数才会打印出所有条件都满足的提交。（即 || 逻辑和 \u0026amp;\u0026amp; 逻辑）\n撤销操作 这一节会有一些撤销操作的教学，注意部分操作是不可逆的。\n替换commit git commit --amend 会“覆盖”你的上一次提交，通常我们会用于修改一些小错误或者重写提交信息。如果只需要更改消息，那么直接运行该指令即可，如果需要修改文件或者提交漏提交的文件，那么可以这样：\n1 2 3 git commit -m \u0026#34;a mistake commit\u0026#34; git add missing_file git commit --amend 这个指令会使新的提交替换掉旧的提交，所以旧的提交完全不存在仓库的历史中。这能使你的提交历史被“修正笔误”或者“忘记提交一个文件”之类的记录弄乱你的记录。\nl## 撤销已暂存的文件 如果你修改了两个文件，想分两次提交，但是已经一次性提交了，应该如何操作？\n在 git status 中，已有提示: git reset HEAD \u0026lt;filename\u0026gt; 来取消暂存。\n如何取消已修改但为未暂存的文件？此事在 git status 中亦有记载：\n使用 git checkout -- \u0026lt;filename\u0026gt; 可以撤销修改，不过这是一个危险的命令，因为实质上是使用上一次提交里的文件版本覆盖掉当前文件。\n远程仓库（remote） 远程仓库指托管在网络中的仓库，与他人协作时需要管理远程仓库。\n远程仓库可以在本地的主机上，这里的远程表明的是仓库在别处而已。\n查看远程仓库 使用 git remote 查看远程仓库的简写，通常来说，你应该能看到 origin ，这是克隆的仓库的默认名字。\n使用 git remote -v 则会额外列出仓库简写的对应的URL。这个指令也会列出全部的远程仓库（如果不止一个）。\n添加远程仓库 使用 git remote add \u0026lt;shrotname\u0026gt; \u0026lt;url\u0026gt; 的格式添加远程仓库并指定简写。\n现在可以使用简写代替这个仓库的URL，如拉取远程仓库的更新 git fetch origin\n从远程仓库抓取与拉取 就如刚才所提：使用 git fetch \u0026lt;remote\u0026gt; 可以获取远程仓库中的数据，并将新数据抓取到本地，值得注意的是，这不会合并到你当前的工作区，所以需要手动合并。\n一般来说， git clone 克隆一个仓库，默认会将这个仓库设置为远程仓库，并添加简写为 origin 。\n如果当前分支已经设置了跟踪远程分支（请等待git分支一节），那么使用 git pull 即可自动抓取远程并合并。另外， git clone 命令会默认设置本地的 master 分支跟踪远程的 master 分支。 运行 git pull 会从克隆的服务器上抓取并自动尝试合并到当前分支。\n推送到远程仓库 使用 git push \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; 即可， 通常来说，有：\ngit push origin master （这是克隆的默认名称）\n并且，只有你拥有远程服务器的写入权限，并且没有其他人推送过，这才是有效的。否则，你需要将他人的工作合并到本地后才能推送。\n查看远程仓库 使用 git remote show \u0026lt;remote\u0026gt; ,如此博客：\n1 2 3 4 5 6 7 8 9 10 11 git remote show origin * remote origin Fetch URL: https://github.com/FOTH0626/foth0626.github.io.git Push URL: https://github.com/FOTH0626/foth0626.github.io.git HEAD branch: master Remote branch: master tracked Local branch configured for \u0026#39;git pull\u0026#39;: master merges with remote master Local ref configured for \u0026#39;git push\u0026#39;: master pushes to master (up to date) 这能显示每个分支会推送的远程分支，哪些远程分支不在本地等等信息。\n远程仓库重命名 使用 git remote rename \u0026lt;old\u0026gt; \u0026lt;new\u0026gt; 这也会改变你远程跟踪的分支名字。\n如果你需要移除一个远程仓库（如你不再使用服务器/不使用某个镜像/某个维护者不再维护），那么可以使用 git remote remove \u0026lt;remote\u0026gt; ，这也会删除远程仓库的跟踪和配置信息。-\n标签 列出标签 使用 git tag 命令（可加上 -l 或者 --list 按照通配符查找)\n创建标签 Git 存在两种标签：轻量（lightweight）与附注（annotated）。\n轻量标签只是某个提交的引用，它是不会改变的。\n附注标签是一个完整的，存储在Git数据库的对象，它是可以被校验的，包含标签创建者的姓名、电子邮件、日期时间、标签信息，并且可以使用GNU Privacy Guard(GPG)进行签名并校验。\n附注标签 使用 -a 参数即可创建附注标签，如 git tag -a \u0026lt;tag\u0026gt; -m \u0026lt;message\u0026gt; ，如果没有显式地使用 -m 那么，将如提交时一样，需要在文本编辑器内输入标签的信息。\n使用 git show \u0026lt;tag\u0026gt; 可以查看该标签的详细信息。有标签创建者信息，标签日期，附注，提交信息。（这里我的显示与书中不同，我额外显示了这次commit的修改文件的具体信息，很奇葩。）\n轻量标签 不额外附带参数即可创建轻量标签，如 git tag \u0026lt;tag\u0026gt; 。\n这时的标签只会展现出提交信息。（不过我还是显示了一堆消息，可能是 git show 的问题？）\n后期打标签（对过去的提交打标签） 对于一个已经提交的记录，可以使用 git tag -a \u0026lt;tag\u0026gt; \u0026lt;checksum\u0026gt;\n1 2 3 4 $ git log --pretty=oneline 33849c071fbd57dbefcb279b97255b24c794f319 (HEAD -\u0026gt; master, tag: 1.0, tag: 0.1) test ded2ebf137ddc0b1f60e09fe3c96a3b88f491033 God Bless You 42a782e56593d75b86ef8f3d52309dc09ed66406 aaa.md 可以使用 git tag -a v0.8 ded2eb 在 God Bless You 打上tag。\n共享标签 默认情况下， git push 并不会推送标签到远程服务器，必须显式地使用 git push origin \u0026lt;tag\u0026gt; 推送标签，或者使用 git push origin --tags 附带所有不在远程仓库的所有tag提交。\n没有简单的方法可以只推送附注标签或轻量标签。\n删除标签 使用 git tag -d \u0026lt;tagname\u0026gt; 。\n例如 git tag -d 0.8 ,与push不会推送到远程一样，这个指令不会删除远程仓库，需要使用 git push \u0026lt;remote\u0026gt; :refs/tags/\u0026lt;tag\u0026gt; 才能更新远程仓库。\n另外一种方式是使用指令： git push origin --delete \u0026lt;tag\u0026gt;\n检出标签 如果想要查看某个标签指向的版本，可以使用 git checkout \u0026lt;tag\u0026gt; ，但是这会让你出于“分离头指针”状态，这会导致不好的副作用。\n这个状态下，你的新提交不会属于任何分支，并且无法访问，除非通过确切的提交哈希。因此，需要进行更改时，需要新建一个分支。（总之我也没看懂，尽量不要使用该该功能？欢迎指正）\nGit别名 可以使用 git config 为命令设置一个别名。如\n1 2 3 4 git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status 当使用 git commit 时， 只需要输入 git ci 。\n别名是非常有用的，所以创建时不要犹豫，比如取消暂存文件的命令可以输入 git config --global alias.unstage 'reset HEAD --' 这让两个命令等价。\n1 2 git unstage \u0026lt;file\u0026gt; git reset HEAD -- \u0026lt;file\u0026gt; 或者有： git config --global alias.last 'log -1 HEAD'\n这样可以快速查看最后一次提交。\n如果想使用外部程序，可以添加 !，如\ngit config --global alias.visual '!gitk' ，可以使用 git visual 调用 gitk 程序。（这GUI真tm的丑。2000年前后的风格）\n总结 这一节我们学习了基础操作，下一节我们来学习Git杀手级特性：Git分支模型。\n","date":"2025-10-18T15:47:07+08:00","permalink":"https://foth0626.github.io/article/progit-book-2/","title":"ProGit Learn Record 2：Git基础"},{"content":"跑步 最近我开始跑步了，为了缓解我的大腿止不住的，需要运动的欲望。\n我的跑步，实际上算不上跑步，不如说是散步的过程中偶尔蛄蛹几下，13分配。\n跑步的过程还是比较惬意的（这种跑速怎么可能不惬意），身体只需要重复摆动，我可以拿我的脑子拿来思考。跑步的时候还是想到了一些东西。\n关于改变 改变不是奇迹，而是一场突袭。它不会悄悄降临，要么强夺横取，要么永不现身。改变不是请客吃饭，不是刺绣，它从不温和——它是一场谋杀，凶手是新我，死者是旧我；一次反攻倒算，力求破茧。改变如不被人为构造，那么就是房间里的大象：你永远知道你需要改变，但你永远不会意识到你必须改变。堕落不需要任何理由，只需要什么都不做，或者随波逐流。但向上需要永不放弃的意志，洞明练达的思考。任何人在任何时间点都可以在30秒内想出至少一个理由解释自己为什么仍然停滞，仍然堕落不堪，仍然虚度光阴：并继续躺着沉浸在奶头乐中。\n坚持向上攀爬本身就是一种拥有强权般的意志才可以做到的行为。\n永远躺在地上，或者在自己燃尽前爬到你的目标。仅此而已。\n在这里写出我所做错的：\n无节制、过于频繁地自渎。有时可以达到 3~4 times/d，最多有 6~8 times/d 过度使用Bilibili、QQ、知乎，过度使用手机。 对时间的不敏感，数小时花费在无意义的信息流中。 混乱的作息。 不健康的饮食，包括结构与过量两个问题。 几乎不进行运动，导致身体的虚弱。 笔记本系统由 ArchLinux 迁移到 Fedora 出于生命来自折腾的原则，我从Arch Linux 迁移到了Fedora42。\nFedora的安装舒适度比Arch高了很多，图形化界面就是好啊。\n软件源不如Aur，但是Flathub也基本解决了我的软件需求。\n其他目前没有感觉。不过我的常用软件并不多：\nc++ 开发工具链——包括但不限于：常用第三方库（似乎已安装部分，如fmt，spdlog）, g++, clangd, cmake 等均在源中。VSCode需要手动配置，略麻烦。 firefox 系统自带 telegram ：flatpak安装 obsidian：flatpak安装 FlClash：Github release下载rpm后本地安装 Fcitx5 ：从源中安装，配置了rime-ice和主题 Vim ","date":"2025-10-15T21:29:08+08:00","permalink":"https://foth0626.github.io/article/miscellany-2025-10-15/","title":"杂谈：2025-10-15"},{"content":" 本系列文章基于《Pro Git》一书，作为本人学习记录\nGit的来源 版本管理是开发中常用的需求，最开始的版本管理软件，基于本地数据库管理，最流行的便是RCS。后来，面对不同系统的开发者需要协同工作的需求，产生了集中版本控制系统（Centralized Version Control Systems，CVCS），但是CVCS会导致一旦服务器不工作就会导致整个仓库的历史遗失，于是针对这一问题，分布式版本控制系统（（Distributed Version Control System，DVCS）诞生了，这种版本控制系统会在下载仓库中的文件时，一同下载历史更改，所以即使服务器挂掉，也可以通过本地的仓库恢复完整记录。\nLinux作为一个系统内核，拥有着极其繁重的版本控制需求。一开始，Linux社区使用Bitkeeper作为版本控制软件，但是随着合作关系的结束，Bitkeeper公司结束了Linux免费使用该软件的权利，于是Linus自己编写Git这个版本控制软件，并且设定了如下目标：\n速度 简单的设计 对于非线性开发的支持（拥有大量的并行开发的分支） 完全基于分布式 高效管理超大规模的项目（如Linux内核） Git不记载每个文件与初始版本文件的差异，它对每个文件进行快照。Git对待数据更像是一个快照流。 Git会把在数据存储前使用哈希进行校验他，这使得Git保证了数据的完整性。 Git一般只会往Git的数据库中添加数据，你很难从Git数据库中删除数据 Git有三种状态：已提交（Committed） 、已修改（modified） 和已暂存（staged） 。\nmodified 表明已修改了文件，但尚未保存到数据库中。 staged 表明对一个已修改文件的当前版本做了标记，使其包含在下次提交的快照中。 committed 表示数据已安全的保存在本地数据库中。 这使得Git有用三个阶段：工作区、暂存区和Git目录。\n工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。 因此，最基本的Git工作流就是：\n修改文件（工作区） 将你的更改暂存（暂存区） 提交更新（将暂存区的快照永久地提交到Git目录中） 命令行 本系列只使用Git 命令行，因为\n不是所有人都一定有GUI工具，但一定有CLI。 GUI通常对Git的所有功能取一个子集，CLI拥有Git的所有功能。 下载并安装Git 请自行在 Git 官网 或通过搜索引擎自行查找下载安装方式。\n配置（config） 在/etc/gitconfig 文件中，包含系统中每一个用户及他们仓库的通用配置。 在 ~/.gitconfig 或 ~/.config/git/config 文件包含当前用户的配置。使用 --global 选项可以使系统中所有仓库生效 项目仓库中 .git/config 是该仓库的设置，使用 --local 可以使git强制使用它（虽然默认就是它）\nWindows 系统在 $HOME 目录下（ C:\\Users\\$User) 的.gitconfig目录，系统级目录在 C:\\ProgramData\\Git\\config\n使用 git config --list --show-origin 查看所有配置 用户信息 使用\ngit config --global user.name \u0026lt;name\u0026gt; 和 git config --global user.email \u0026lt;email\u0026gt;\n如果你想在不同的项目使用不同的名字和邮箱，那么在那个项目里使用不带--global 的命令。\n文本编辑器 配置默认文本编辑器，Git 会在输入信息时使用它，如果未配置，则会调用默认的编辑器\ngit config --global core.editor EDITOR\n检查配置 使用 git config --list 检查所有能找到的配置。\n使用 git config \u0026lt;key\u0026gt; 如 git config user.name 检查某一项配置\n使用 git config --show-origin \u0026lt;key\u0026gt; 来检查哪一个文件最后设置了该值\n获取帮助 使用 git help \u0026lt;verb\u0026gt; 或 git \u0026lt;verb\u0026gt; --help 或 man git-\u0026lt;verb\u0026gt; 获取manpage。如git help config\n如果使用 -h ，则可以获得简短的快速参考\n","date":"2025-10-14T15:21:06+08:00","permalink":"https://foth0626.github.io/article/progit-book-1/","title":"ProGit Learn Record 1 ：起步"},{"content":"Intro 前几天被朋友问到 C++11中引入了哪些新特性。自己竟然直接语塞答不出来，发现自己虽然知道一些似乎高大上的名词，譬如CTAD，concepts，三五定律等等，但对c++整体的了解存在不足，于是有了这篇文章。当然这篇文章的水平也十分低下，笔者对于所提到的知识的细节事实上非常不足，许多概念都需要借助LLM为我讲解，如有错误，还请批评指正。\nReference:\nCurated Learning C++ Playlist\nC++11 auto ranged-for loops 1 2 3 for(const auto \u0026amp;i : vec){ //do something } lambda unique_ptr constexpr variadic templates C++14 对C++11的小修小补\nauto 函数返回类型可以是 auto\nlambda优化 lambda可以使用auto作为参数类型，自动捕获不同类型的变量。 增强了捕获机制，可以使用移动捕获unique_ptr，或者在捕获时创建一个新变量（你甚至可以在捕获里再写一个lambda）。\nmake_unique 现在可以使用make_unique 而不是 new 来初始化指针了（我们整个程序都可以不使用new 和 delete了）。\nconstexpr 强化了constexpr 的功能。比如循环，分支等都可以使用constexpr了\nC++17 Copy/Move Elison（强制复制消除） 在C++14中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; struct MyType { MyType() { std::cout \u0026lt;\u0026lt; \u0026#34;Default constructor\\n\u0026#34;; } MyType(const MyType\u0026amp;) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy constructor\\n\u0026#34;; } MyType(MyType\u0026amp;\u0026amp;) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;Move constructor\\n\u0026#34;; } ~MyType() { std::cout \u0026lt;\u0026lt; \u0026#34;Destructor\\n\u0026#34;; } }; MyType create_object() { return MyType(); // 返回一个临时对象 } int main() { MyType obj = create_object(); return 0; } 会输出Default constructor，（会消除掉一个移动），但是这是建议进行的，是由编译器进行的优化，并且要求复制构造/移动构造是可访问的。在17中，这要求成为强制执行。所以下面这段代码能在C++17而不能在C++14通过编译。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; struct NoCopyMove { NoCopyMove() { std::cout \u0026lt;\u0026lt; \u0026#34;Default constructor\\n\u0026#34;; } NoCopyMove(const NoCopyMove\u0026amp;) = delete; // 删除拷贝构造 NoCopyMove(NoCopyMove\u0026amp;\u0026amp;) = delete; // 删除移动构造 ~NoCopyMove() { std::cout \u0026lt;\u0026lt; \u0026#34;Destructor\\n\u0026#34;; } }; NoCopyMove create_object() { return NoCopyMove(); // 这是一个纯右值 (prvalue) } int main() { NoCopyMove obj = create_object(); // 初始化 obj } STL 和 lambda 中 开始加入 constexpr 的支持 string_view 一个非拥有的，轻量的只读的字符串工具，除非有修改原始字符串的需求，否则大部分情况都可以使用string_view 。不过需要注意指向对象先于 string_view的生命周期前被销毁造成空悬引用。\nClass Template Argument Deduction 类模板参数类型推导，CTAD，如\n1 2 3 #include \u0026lt;array\u0026gt; std::array arr{1,2,3,4,5}; 不需要显式写出array的参数\u0026lt;int,5\u0026gt;。\nfold expression 过去的模板处理多个参数需要进行递归，如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; // 递归的终止条件（基础情况） template\u0026lt;typename T\u0026gt; T sum(T t) { return t; } // 递归的模板定义 template\u0026lt;typename T, typename... Args\u0026gt; T sum(T t, Args... args) { return t + sum(args...); // 递归调用，将当前参数与剩余参数的和相加 } int main() { std::cout \u0026lt;\u0026lt; sum(1, 2, 3, 4, 5) \u0026lt;\u0026lt; std::endl; // 输出 15 } 而在C++17中，\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; template\u0026lt;typename... Args\u0026gt; auto sum(Args... args) { return (args + ...); // 这就是折叠表达式！ } int main() { std::cout \u0026lt;\u0026lt; sum(1, 2, 3, 4, 5) \u0026lt;\u0026lt; std::endl; // 输出 15 } structured bindings 可以将 std::pair这样类型的两个成员分别绑定到不同的变量上，并且不需要提前声明（即使用std::tie)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;utility\u0026gt; std::pair\u0026lt;std::string, int\u0026gt; get_person() { return {\u0026#34;Alice\u0026#34;, 30}; } int main() { auto [name, age] = get_person(); // 一行代码完成解构和声明 //name type : basic_string\u0026lt;char\u0026gt; //age type : int std::cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;, Age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; std::endl; } if-init expressions C++17 可以在 if 语句的条件部分，直接声明并初始化一个变量。这个变量的作用域被严格限制在 if 及其对应的 else if / else 块内部。避免了作用域的污染。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; std::map\u0026lt;std::string, int\u0026gt; user_ages = {{\u0026#34;Alice\u0026#34;, 30}, {\u0026#34;Bob\u0026#34;, 25}}; void check_user_cpp17(const std::string\u0026amp; name) { // 初始化和条件检查在一行内完成 if (auto it = user_ages.find(name); it != user_ages.end()) { // it 的作用域从这里开始 std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#34; years old.\u0026#34; \u0026lt;\u0026lt; std::endl; // it 在 if 块内可见 } else { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; not found.\u0026#34; \u0026lt;\u0026lt; std::endl; // it 在 else 块内也可见 (此时 it == user_ages.end()) } // it 的作用域在这里结束！ // 在这里访问 it 会导致编译错误，这是我们期望的行为！ } C++20 我们引流狗最爱的C++20，永远遥遥无期的 module 喜欢吗（\nDesignated Initializers（指定初始化器） 1 2 3 4 5 6 7 struct S{ int i; int j; int k; }; S s{.i = 1, .j = 2, .k = 3}; 可以指定成员初始化（其余成员默认初始化）。 有如下要求\n必须是聚合类型，即：没有自定义构造函数，没有private 或 protected 类型的成员，没有基类，没有虚函数。（感觉基本上就是适用于一些struct 初始化） 初始化时成员不允许乱序，不允许多次出现。 太空船运算符（三向比较运算符） 这东西真有人用吗（）\n在 \u0026lt;compare\u0026gt; 中定义了 std::strong_ordering （强排序） std::weak_ordering （弱排序） std::partial_ordering （偏排序）\nstd::strong_ordering std::strong_ordering 存在的关系分别为 less equal greater ，当两者关系为equal 时，两者可交换。\n通常用于 int ，标准库容器等。\nstd::weak_ordering 相较于 std::strong_ordering ，std::weak_ordering 的关系为less equivalent greater ，其中的 equivalent 不是严格的相等关系，而是等价关系 ：如 \u0026quot;hello\u0026quot; 和 \u0026quot;HELLO\u0026quot; 。两个关系为 equivalent 的对象不可以交换,但是== 运算符为真。\nstd::partial_ordering 存在关系为less equivalent greater unordered ，其中 unordered 类型 意思是无法比较，此时：A\u0026lt;B,A\u0026gt;B,A==B,A\u0026lt;=B,A\u0026gt;=B 全部为false . 如一个浮点数和 NaN 比较结果就是std::partial_ordering::unordered 。\n编译器会根据返回的比较结果，自动生成出 \u0026lt; \u0026gt; == != \u0026lt;= \u0026gt;= 的bool值。 比较过程是字典式的，比如说，在第一个成员中就可以判断出 小于 的关系，那么即使之后的每一个成员都是 大于 也是返回小于。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #import \u0026lt;iostream\u0026gt; struct S{ int i; int j; int k; constexpr auto operator\u0026lt;=\u0026gt;(const S\u0026amp;) const = default; }; int main(){ S s1{.i =1, .j = 5, .k = 5}; S s2{.i =2, .j = 2, .k = 2}; bool res = s1 \u0026lt; s2; std::cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; std::endl; //输出结果为 1 return 0; } module 不清楚具体实现，听朋友说是预编译，可以不导入头文件改为导入模块\ncoroutines 不清楚,目测和协程有关\nconcepts 可以对模板进行约束，提高了模板编程的质量。\n譬如 我之前在写一个自己的矩阵类，初始化时需要满足一个初始化列表中有且仅有16个元素，朋友跟我说可以使用 requires 关键词约束。\n\u0026lt;format\u0026gt; 感觉不如。。。fmt\n简单来说，可以使用类似于 (\u0026quot;info {}:{}\u0026quot;, id, description) 这种语法来灵活的输出，并且，这种可以在 {} 输入对应的索引达到乱序的目的。\n\u0026lt;source_location\u0026gt; 可以在获得源文件的信息，如文件名，行号，函数名（这不是我们的__FILE__, __LINE__, __func__吗），并且是在编译时获取的，在运行时开销非常小。\n万年历的功能增强 \u0026lt;ranges\u0026gt; emm我也不会讲怎么形容它，总之就是对于容器的数据有了更方便、更安全的处理方式？\n这里有一个来自gemini的示例。顺带一提 管道运算符| 和命名空间别名似乎也是C++20才引入的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #import \u0026lt;iostream\u0026gt; #import \u0026lt;vector\u0026gt; #import \u0026lt;ranges\u0026gt; int main(){ std::vector numbers{1,2,3,4,5,6,7,8}; namespace views = std::views; auto process_view = numbers | views::filter([](int n ){return n%2 == 0 ;}) | views::transform([](int n){return n*n;}); return 0; } constexpr 虚函数可被声明为constexpr ，可在编译时进行多态调用 constexpr 可以被用于内存分配和释放了，所以std::vector 等容器可以在编译期求值。 constexpr 函数可以使用try-catch了 新关键词 consteval ,被声明的函数必须在编译器执行，而 constexpr 可以在运行时运行。 新关键词 constinit ，变量必须静态初始化。 \u0026lt;span\u0026gt; span是一个轻量级的，安全的，高效的用于操作连续内存队列的一部分或全部（如 std::vector ， std::array 或者C-style数组 ）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;span\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;iostream\u0026gt; // 函数接受一个 span，可以处理所有连续容器 void print_elements(std::span\u0026lt;const int\u0026gt; data) { std::cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; data.size() \u0026lt;\u0026lt; std::endl; for (int n : data) { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; } void test_span() { // 1. 原生数组 int arr[] = {1, 2, 3, 4, 5}; print_elements(arr); // 2. std::vector std::vector\u0026lt;int\u0026gt; vec = {10, 20, 30}; print_elements(vec); // 3. std::array std::array\u0026lt;int, 2\u0026gt; arr20 = {55, 66}; print_elements(arr20); // 4. 作为子序列视图 // span 可以通过构造函数或 subspan() 方法表示原序列的子集 std::span\u0026lt;int\u0026gt; vec_span(vec); auto sub_span = vec_span.subspan(1, 1); // 从索引 1 开始，长度为 1 // 通过 span 修改原始数据 sub_span[0] = 999; std::cout \u0026lt;\u0026lt; \u0026#34;Modified vec[1]: \u0026#34; \u0026lt;\u0026lt; vec[1] \u0026lt;\u0026lt; std::endl; // 输出 999 } thread updates 我不知道\n","date":"2025-10-05T16:36:14+08:00","permalink":"https://foth0626.github.io/article/some-cpp-new-parts-features/","title":"some C++ new Parts Features in 11/14/17/20"},{"content":"只是一些碎碎念\n我的奇葩技术栈 从各种意义上来说，我的技术栈都只能用左右脑互搏来形容，总觉得这两年多的学习啥都没学明白。让我想想。\n软件操作：Blender、Maya、Unreal都只会基本操作（看完30分钟入门级别的那种，快捷键都按不明白），Unity也不咋地，各个模块的功能很难说自己懂多少(甚至有哪些模块都不清楚)。 HLSL：更准确的说是ShaderLab？这个可能还行，但是本身HLSL语言没有太多奇技淫巧，写shader更重要的是如何理解美术的需求，物体表面属性和光线如何交互。写shader是最不重要的一环，如何理解复杂的需求才更重要。 C++：学的更抽象，本身入门就抽象，先从小彭老师开始看，平地起高楼这一块属于是拉满了，到现在也没明白C++11/14/17/20/23/26各个版本都更新些啥，也不清楚STL都有些啥。属于也就知道个std::vector ，还连成员函数都不清楚，CMakeLists.txt 也得边写边查。 C# ：更是重量级，一点没学，用C++ 的前世记忆加上跟着麦扣教程直接抄这一块。 Python：一点不想碰的傻逼语言，看缩进看的我头疼，调包界最长的河，最高的山，我个人绝对不会主动碰，除非有需求。 建模/材质：纯史，印象里流程是 中模-\u0026gt;高模-\u0026gt;拓扑-\u0026gt;低模-\u0026gt;展UV-\u0026gt;烘焙 ，好像还漏了几步。 3D数学：只有直观理解，fw的没边，也就能吹吹牛逼了。 图形学：知乎看了不少文章，只能说啥都知道一点，当然也就一点，知道个名词，最多知道有什么作用的级别，反正绝大部分feature都没搓过实现（？），指定一个效果我抄也能抄出来，从零实现一整套系统确实不行。 信息检索能力（？）：不知道怎么评价，这种东西一般都是隐性的，我能Google/DuckDuckGo/Bing多引擎一起搜，问LLM后再从搜索引擎求证，会额外在Bilibili（这个基本不抱指望）/Youtobe搜一搜。 经验：0实际生产环境开发经验，无实习这一块。 审美：不清楚，pixiv600+关注能反应审美吗（），知道一些基础的对比，色相之类的美术知识，不过缺少实践，还知道一些视觉相关的生物学知识。 自学能力：会主动看GDC，能根据一个topic找相关视频看，能找相关书籍，会根据Reference一路找过去。 Linux：BTW,I use ArchLinux，只能说机缘巧合下使用Arch作为系统，是一种很独特的体验，但是我的linux基础并不好，只能说难绷，我连鸟哥的linux私房菜都没看完几章，每天 paru 更新一下就好，还挺养老（）。Vim 会基础操作， hjklioaug 之类的 ，但是不会高级操作，也不会自己写插件，只能算是不会吧。 我也不知道我的水平如何。总之挺搞的。 一些关于游戏的topic 大部分玩家都是软弱的，他们没有自我。-foth li\n似乎大部分玩家都没有自己独特的偏好，只要厂商给他们推送什么，他们都能欣然接受，于是就有超级大罐头厂育碧。而且游戏厂商才会尝试大量的进行媒体话语权的争夺\n从这个角度看，或许一个有自己明确喜好，清楚自己喜爱哪种游戏类型，对哪些类型既不排斥又不喜爱，对哪些类型永不接触的玩家才算是真正有主动性的玩家。其他人称为用户或者消费者也无不可。（当然，这只是一个暴论。）\n营收方式和游戏质量/游戏体验没有任何关系，买断和free to play都只是一种营收方式，选择不同而已。如果一个免费游戏能够不氪金或者很少氪金就能体验大部分甚至全部内容，那在我看来就是无可指摘的。而买断制游戏不提供与定价相同的内容和体验，那就是诈骗。售价？开发商收回成本之后，任意时刻都可以进行倾销，售价的慢慢下降既可以说是避免恐慌也可以说多赚一点是一点了。 延迟游戏是我选择的方式，避免傻逼的社区恶心自己，也是让时间沉淀出真正值得品味的游戏。当然，我也有会抢首发的游戏。\nending time to SLEEP，bye\n","date":"2025-10-02T22:33:25+08:00","permalink":"https://foth0626.github.io/article/miscellany-2025-10-02/","title":"杂谈：2025-10-02"},{"content":"前两天刚过完21岁生日，虽然我一直对过生日没什么感觉，这次的生日也就是平平淡淡地过了一天，什么也没做。但似乎以生日为界限，做一些近期的随笔也是不错的选择。\nInternet Break 作为一个小学开始就接触互联网，现在也算有着10年以上网龄的老网民。近些年却越发感觉整个互联网充斥着无序的杂音，评论区只有无意义的对骂，视频制作者只需要捕风捉影式地从不知道哪里的信源中断章取义出一个偏激的观点，就能产生一个谣言，一次舆论风波。这是逃避，我清楚，但是逃避虽可耻但有用。本人最近看b站越来越少开弹幕了，低智的言论充满了整个视频时间轴，光是看到这样的蠢人，就让我脑袋发疼。\napp的野兽化 互联网只产生情绪和立场。在互联网上，长效的逻辑是缺位的，不是说不可以拥有情绪，但是逻辑的沉默是危险且有害的。所以在当代，延迟消费一切内容是毫无疑问有益的。\n传统互联网和现代的互联网逻辑是不同的，传统互联网最常见的用法是用户主动搜索，主动权是在用户个体；但当代互联网不同，它的逻辑是推送，推送是由公司决定的，主动权在公司手中。以抖音为例刷新是当代互联网的一个特点，甚至是最大特点，刷新是动物化的，刷新这个动作永不终结：刷新的目的就是下一次刷新，现实生活中不存在终结一切的一次刷新存在，所以这个meta永远不会终结，这场永不落幕的舞会只会因为身体崩溃而被暂时打断。所以说，app是一种野兽化的存在：一头野兽在吃完一块肉的欲望，只会指向吃下一块肉的欲望。只有当外部的打断来临，这个欲望才会被暂时终止。野兽化的不仅是用户，也包括公司，资本总是渴望着扩张，所以不断地指向下一个用户，抖音模式太过成功，以至于所有平台都得学习抖音模式，以求苟活。\n排泄链 很难想像，只是把别的平台生产的内容，哪怕是一句意义不明的话，一张模糊不清的图，都可以成为一种收获流量的方式，互联网犹如人体蜈蚣一般，一节一节地向下搬运观点，甚至还有回环般的相互搬运，最终成为互联网就成为了一个巨大的厕所，而用户则成为了赛博老八，不断地找屎吃。💩吃多了，最终脑子也会变成💩的样子，成为丧尸。\n丧尸化的互联网 整个互联网似乎都在丧尸化：无数的bot账户存在于各个软件，甚至比人还多。如何推定一个账户是人还是机器？：声音可以用语音模型，图片和视频可以生成，话语可以用LLM产生。整个互联网似乎如同一个“他心问题”一般，你只能确定自己是一个真人。其他每个人都可能是僵尸般的机器。\n关于技术 我自认为对于技术的理解算不得深入，甚至可以说浅薄。我的行为模式甚至算不上一个代码爱好者，但或许浅薄也有浅薄的好处，只需一些微小的进步，便足以让我喜悦地分享出来。\n技术视野 我理解的技术视野是指，对于某种效果/功能/需求，能够联想到的所有可行的用来解决这问题的技术方案的程度的能力，包括但不限于，在宏观上的技术选型、代码架构，比如做头发，是使用体块法，面片法，还是纯物理模拟；渲染用kajiya-kay还是基于物理的毛发渲染。微观上，可以看作使用哪些具体的库，具体的代码设计模式等等。做到又精又广是困难的，从这个角度看，长期阅读技术分享是很重要的。除此之外，也可以看一些类似文献综述之类的加深理解（比如实时渲染界的圣经《RTR4》）。\n抽象 抽象一直是CS中的重要话题，从硬件电路，到机器语言，到汇编，到C，到高级语言，再到第三方库，随着一层层的抽象，越来越高级，也越来越对人的心智负担降低，但越高的抽象便越发远离本质：我们只知道发生了什么，却不知道为什么发生，最后连bug也不会修，只能指望玄学。不能什么都只依赖抽象，例如只知道Vue,React,却不知道html,css,js三大件；又比如整天写ORM,最后却连Sql都不知道。但也不应该一昧地击穿抽象层，例如一直使用堆、栈而非静态存储区和动态存储区。 我粗浅的想法是：在较完整地学习了当前所需的技术栈后，可以向下学习更底一层的技术，并理解两者之间的通信机制，它们之间如何协作，并区分两者可能存在的区别。\n","date":"2025-08-04T16:57:22+08:00","permalink":"https://foth0626.github.io/article/write-on-21th-birthday/","title":"杂感：写在我的21岁生日后"},{"content":" Refer:3D Toon Rendering in \u0026lsquo;Hi-Fi RUSH\u0026rsquo;\nGoals 使用ue4进行卡通渲染，包括角色和场景。\n优先确保60fps\n画面干净锐利鲜亮\noverview Deferred lighting + toon post-processing.\nTarget: decouple toon rendering and gbuffer rendering. Artists can change toon postprocess volume to change areas which want to use toon shading.\nuse individual toon postprocessing params for each lighting layer\nShadow color Target:Need different shadow color.\nUse shadow volume ,implemented by mapping 3d texture to 3d world position.\nAmbient cubemap volume to customlize ambient\nComic shader Lit: halftone dot Shadow : hatching lines Shader on / off Dirty GI and SSAO, remove gradation\nUse smoothstep and alpha blend to anti aliasing\nTips : not suit bloom things\nAvoid these halftones look like print on the camera instead of on the models(we dont want this )\nAdapt to luminace strength, larger the luminace bigger\nToon lights In base pass , change lighting in forward render.\nMostly use decal lights instead of forward lights\nStep gradiation lights\nDecal lights can use a decal volume to specifically assign which area needs to be lighted . Also, it will have a smaller area to lighting and better art control instead of forward lights because of the decal volume. Decal volume can be used to prevent light leaking .\nCharacter render is not influenced by environment lighting(decal lights and forward lights).\nShadows Shadow-only lights use shadow-only lights to player, character and environment.\nplayer and giant-boss\u0026rsquo;s shadow is seperated from environment cascaded shadows.\nEnemy shadows enemy shadow use capsule shadows for high performance.\nFor little floating in the air enemy, use cpu raycast to decal shadows\nStatic shadow map 艺术家手动放置摄像机生成一张深度图，使用volume以渲染这些深度图对应的阴影。\n预烘焙相机的深度图。\n4x4的pcf消除锯齿。\nGI ue4 light mass 烘焙时间太长\n自定义一套light volumetric light map 以提高烘焙速度和可用性。\n原因之一：可选择需要GI烘焙的部分区域\n修改了ue4 将 光照探针按照per actor 存储 而不是per level\nGI workflow 用一个world volume lighting volumer actor 选择需要烘焙GI的区域\n开始烘焙，等待1，2mins，区域内的GI烘焙完成\nToon face shadow Face shadow should always clean .\nProblems:\nModel normal will lead to a messy shadow Face motion will break shadow shape Artist cant solve 1 and 2 problems by adjusting model Solution : mihoyo \u0026rsquo;s sdf face shadow (i can do it ,so i dont explain it )\n","date":"2025-06-08T15:41:35+08:00","image":"https://foth0626.github.io/article/gdc-2024-hifirush-toonrendering-notes/face2_hu_cfc98133556dde49.png","permalink":"https://foth0626.github.io/article/gdc-2024-hifirush-toonrendering-notes/","title":"[GDC]3D Toon Rendering in 'Hi-Fi Rush'"},{"content":" 在开始今天的话题前，我先来叠个甲，本人的二次元经历不算多，始于大约四年级左右看的第一部番《散华礼弥》，之后便到了初中喜欢上东方，在大约一年半到两年的“狂热”后，我飞快的退出了对东方的关注，只保留一些up主的关注，偶尔看看东方的图。对正作的了解仅到东方绀珠传，到现在的锦上京等最新作品，完全没有了解。偶尔看些废萌，芳文社之流，兼有看一些御宅族研究之类的论述，去年（24年）暑假看了mygo，今年ave mujica开播前狂热的社区让我抽离，立下不看一年以内新番的规矩，以冷却评价。以上。\n开始今天的话题之前，我先说一件这两天刷知乎看到的事，仅作为一个引子：库洛申请了一个专利，名称是：“一种用于游戏角色及生物模型设计的形象优化方法”，依我的理解，大概就是根据玩家对于某种标签（如黑长直，水手服，眼镜等所谓的“萌点”）的喜好程度，对于各个人体部位的不同标签，进行组合。当然，根据当下的流行语，我们也可以用戏谑的说法称呼其为“拼好人”。\n存在主义，或者更久远一些，起源于尼采的一声“上帝已死”的痛苦的哀嚎，告诉我们：超验性的意义已然崩解，人从此被丢到人性的荒原，上帝——也就是意义——就此离场。意义的丧失，在动画产业带来的结果就是叙事的缺失：人们不再关注作品中表达了什么样的思想，转而囤积符号。但问题是，这种囤积符号的欲望是动物性的：人的欲望是社会性的，它渴望着另一个主体与自己的互动，并通过征服其他主体来获得欲望的自我满足，并在征服了他者后继续指向另一个主体进行征服。但动物不同，动物性的欲望是主体和客体之间的，例如当我饥饿的时候，进食的欲望便会指向一块肉或者别的什么食物，这种欲望是主客体之间的，它不会指向下一个对象，而是在完成之后继续指向自身。人与人之间社会性的欲望，构成了征服和被征服，主人和奴隶的关系，历史便在征服与反抗之间不断螺旋上升，普通人也可以在这种语境下获得人生的意义。人的野兽化，或者引用黑魂的术语：游魂化，最终会导致人作为人的主体也最终丧失，最终导致主体和客体的差别的丧失。\n动物化的御宅们，为了逃离现实社会的宏大叙事，游离在社会边缘的小圈子中，又被网购和外卖所组成的庞大系统所包围，满足自己的生存需求，再也不需要和他人进行交流，彻底的动物化。相较于虚构时代，动物化的御宅们就连虚拟世界的宏大叙事也不再关心。举个例子，高达被创作出来，是为了表达作者的反战思想，但新生代的宅们，只关注各个模型的各种参数，并大书特书不同模型的区别，作者真正表达的思想却不再有人关心了。\n这种动物的欲望，在御宅身上的最终形态便是对于符号的囤积：人设。一个角色被简单粗暴地拆分成了发色，瞳色，配饰，服装，社会身份等不同符号的堆砌，最终产生出畸形的怪胎：并非外观意义上的，而是叙事背景的缺失——人们不再关注这个角色的成长经历、内心挣扎、人物弧光，转而粗暴地关注角色是否符合自己的xp。资本热爱这种符号的增殖：相较于有风险的叙事的创作，符号的堆砌无疑是更稳妥的做法。于是动画业界便无休止地生产套路化的异世界，以及买厕纸送插画的轻小说。（事实上，我曾经就尝试过手动列出所有我能想到的Tag/萌点，然后手动拼凑出一个角色，不过后来意识到手动枚举不如直接上萌娘百科上找然后凑来的效率高。） 而御宅们也心甘情愿地完成了从粉丝到消费者的身份转变，御宅们只想囤积符号以满足自己的动物性欲望。\n但所幸，我们的创作，与叙事的关系并非绝望，在传统的中心化的创作者与粉丝的关系破灭后，仍有一部分人，我们称其为同人作者，在沐浴曾经创作的荣光后，因自己心中一丝回荡着的对意义追寻的回想，也选择创作，并期望与他人建立联系，取得他人的承认。哪怕自己所创作的永远只是边角料和残渣，永远只是那个过去的伟大的存在的一丝缩影，哪怕知道自己的创作永远比不上原著，只是回忆，修补……但即使如此，我们也心甘情愿地踏上这条无归的旅程，在这条道路上，我们会遇到其他的同样因贪恋过去的伟大存在，而追寻过去一丝残影的同路人，这条路上的所有人都是残缺的，却都选择前进，即使最终的结果不会改变，即使所有同路人都将消失，但这一切，难道称不上伟大吗？\n“太阳坠落之后，群星是否也应当熄灭？”我又想到另一句话，作为一个超越时空的回答：“星星之火，可以燎原。”\n","date":"2025-06-03T16:29:49+08:00","permalink":"https://foth0626.github.io/article/creation-and-symbol/","title":"叙事和符号，创作之思"},{"content":" 首先零帧起手 我就纳闷了，unity6了，urp大版本号都17了，byd 傻逼unity官方，你们引擎团队养的7k号人，都他妈吃屎的吧，到现在连个URP模板都没有，每次创shader默认都是cg语言😅😅，我真他妈服了。\n然后是模板，源自养乐多大佬，我之后又根据自己的需求魔改过，后续也可能会继续魔改。\nGithub仓库地址：FothUrpShaderTemplate\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 Shader \u0026#34;Foth/Template\u0026#34; { Properties { [Header(Main Maps)] _Color (\u0026#34;Color\u0026#34;, Color)=(1,1,1,1) [NoScaleOffset] _MainTex (\u0026#34;Texture\u0026#34;,2D)=\u0026#34;white\u0026#34;{} [NoScaleOffset] _OtherDataTex (\u0026#34;Other Data Tex\u0026#34;,2D) = \u0026#34;white\u0026#34;{} [NoScaleOffset] _OtherDataTex2 (\u0026#34;Other Data Tex 2\u0026#34;,2D) = \u0026#34;white\u0026#34;{} [NoScaleOffset] _OtherDataTex3 (\u0026#34;Other Data Tex 3\u0026#34;,2D)= \u0026#34;white\u0026#34;{} _AlphaClip(\u0026#34;Alpha Clipping\u0026#34;,Range(0,1))=0.333 [Header(Option)] [Enum(UnityEngine.Rendering.CullMode)] _Cull (\u0026#34;Cull (Default back)\u0026#34;,Float)=2 [Enum(Off,0,On,1)] _ZWrite (\u0026#34;ZWrite (Default On)\u0026#34;,Float)=1 [Enum(UnityEngine.Rendering.BlendMode)]_SrcBlendMode (\u0026#34;Src blend mode (Default One)\u0026#34;,Float)=1 [Enum(UnityEngine.Rendering.BlendMode)]_DstBlendMode (\u0026#34;Dst blend mode (Default Zero)\u0026#34;,Float)=0 [Enum(UnityEngine.Rendering.BlendOp)]_BlendOp (\u0026#34;Blend operation (Default Add)\u0026#34;,Float)=0 _StencilRef (\u0026#34;Stencil reference\u0026#34;,Int)=0 [Enum(UnityEngine.Rendering.CompareFunction)]_StencilComp (\u0026#34;Stencil compare function\u0026#34;,Int)=0 [Enum(UnityEngine.Rendering.StencilOp)]_StencilPassOp (\u0026#34;Stencil pass operation\u0026#34;,Int)=0 [Enum(UnityEngine.Rendering.StencilOp)]_StencilFailOp (\u0026#34;Stencil fail operation\u0026#34;,Int)=0 [Enum(UnityEngine.Rendering.StencilOp)]_StencilZFailOp (\u0026#34;Stencil Z fail operation\u0026#34;,Int)=0 //[Header(SRP Default)] //[Toggle(_SRP_DEFAULT_PASS)]_SRPDefaultPass (\u0026#34;SRP Default Pass\u0026#34;,Int)=0 //[Enum(UnityEngine.Rendering.BlendMode)]_SRPSrcBlendMode (\u0026#34;SRP src blend mode (Default One)\u0026#34;,Float)=1 //[Enum(UnityEngine.Rendering.BlendMode)]_SRPDstBlendMode (\u0026#34;SRP dst blend mode (Default Zero)\u0026#34;,Float)=0 //[Enum(UnityEngine.Rendering.BlendOp)]_SRPBlendOp (\u0026#34;SRP blend operation (Default Add)\u0026#34;,Float) =0 //_SRPStencilRef (\u0026#34;SRP stencil reference\u0026#34;,Int)=0 //[Enum(UnityEngine.Rendering.CompareFunction)]_SRPStencilComp (\u0026#34;SRP stencil compare function\u0026#34;,Int)=0 //[Enum(UnityEngine.Rendering.StencilOp)]_SRPStencilPassOp (\u0026#34;SRP stencil pass operation\u0026#34;,Int)=0 //[Enum(UnityEngine.Rendering.StencilOp)]_SRPStencilFailOp (\u0026#34;SRP stencil fail operation\u0026#34;,Int)=0 //[Enum(UnityEngine.Rendering.StencilOp)]_SRPStencilZFailOp (\u0026#34;SRP stencil Z fail operation\u0026#34;,Int)=0 } SubShader { Tags { \u0026#34;RenderPipeline\u0026#34; = \u0026#34;UniversalPipeline\u0026#34; // //\u0026#34;RenderType\u0026#34; = \u0026#34;Background\u0026#34; \u0026#34;RenderType\u0026#34; = \u0026#34;Opaque\u0026#34; // \u0026#34;RenderType\u0026#34;=\u0026#34;Transparent\u0026#34; // \u0026#34;RenderType\u0026#34;=\u0026#34;TransparentCutout\u0026#34; // \u0026#34;RenderType\u0026#34;=\u0026#34;Overlay\u0026#34; // //\u0026#34;Queue\u0026#34; = \u0026#34;Background\u0026#34; \u0026#34;Queue\u0026#34;=\u0026#34;Geometry\u0026#34; //\u0026#34;Queue\u0026#34; = \u0026#34;AlphaTest\u0026#34; //\u0026#34;Queue\u0026#34; = \u0026#34;Transparent\u0026#34; //\u0026#34;Queue\u0026#34; = \u0026#34;TransparentCutout\u0026#34; //\u0026#34;Queue\u0026#34; = \u0026#34;Overlay\u0026#34; //\u0026#34;IgnoreProjector\u0026#34; = \u0026#34;True\u0026#34; } //LOD 100 HLSLINCLUDE #include \u0026#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\u0026#34; #include \u0026#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\u0026#34; CBUFFER_START(UnityPerMaterial) float4 _Color; Texture2D _MainTex; Texture2D _OtherDataTex; Texture2D _OtherDataTex2; Texture2D _OtherDataTex3; float _AlphaClip; CBUFFER_END struct UniversalAttributes { float4 positionOS : POSITION; float4 tangentOS : TANGENT; float3 normalOS : NORMAL; float2 texcoord : TEXCOORD0; }; struct UniversalVaryings { float2 uv :TEXCOORD0; float4 positionWSAndFogFactor :TEXCOORD1; float3 normalWS :TEXCOORD2; float4 tangentWS :TEXCOORD3; float3 viewDirectionWS :TEXCOORD4; float4 positionCS :SV_POSITION; }; UniversalVaryings MainVS(UniversalAttributes input) { VertexPositionInputs positionInputs = GetVertexPositionInputs(input.positionOS.xyz); VertexNormalInputs normalInputs = GetVertexNormalInputs(input.normalOS,input.tangentOS); UniversalVaryings output; output.positionCS = positionInputs.positionCS; output.positionWSAndFogFactor = float4(positionInputs.positionWS,ComputeFogFactor(positionInputs.positionCS.z)); output.normalWS = normalInputs.normalWS; output.tangentWS.xyz = normalInputs.tangentWS; output.tangentWS.w = input.tangentOS.w * GetOddNegativeScale(); output.viewDirectionWS = unity_OrthoParams.w == 0 ? GetCameraPositionWS() -positionInputs.positionWS : GetWorldToViewMatrix()[2].xyz; output.uv = input.texcoord; return output; } float4 MainFS (UniversalVaryings input) : SV_Target { float3 normalWS = normalize(input.normalWS); float3 positionWS = input.positionWSAndFogFactor.xyz; float3 viewDirectionWS = normalize(input.viewDirectionWS); float3 tangentWS = normalize(input.tangentWS.xyz); float3 bitangentWS = cross(normalWS,tangentWS) * input.tangentWS.w; float2 uv = input.uv; return float4(0,0,1,1); } ENDHLSL //Shadow Map Pass Pass { Name \u0026#34;ShadowCaster\u0026#34; Tags { \u0026#34;LightMode\u0026#34;=\u0026#34;ShadowCaster\u0026#34; } ZWrite [_ZWrite] ZTest LEqual ColorMask 0 Cull [_Cull] HLSLPROGRAM #pragma multi_compile_instancing #pragma multi_compile _ DOTS_INSTANCING_ON #pragma multi_compile_vertex _ _CASTING_PUNCTUAL_LIGHT_SHADOW #pragma vertex vert #pragma fragment frag float3 _LightDirection; float3 _LightPosition; struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float2 texcoord : TEXCOORD0; }; struct Varyings { float2 uv : TEXCOORD0; float4 positionCS : SV_POSITION; }; float4 GetShadowPositionHClip(Attributes input) { float3 positionWS = TransformObjectToWorld(input.positionOS.xyz); float3 normalWS = TransformObjectToWorldNormal(input.normalOS); #if CASTING_PUNCTUAL_LIGHT_SHADOW float3 lightDirectionWS = normalize(_LightPosition - positionWS); #else float3 lightDirectionWS = _LightDirection; #endif float4 positionCS = TransformWorldToHClip(ApplyShadowBias(positionWS,normalWS,lightDirectionWS)); #if UNITY_REVERSED_Z positionCS.z = min(positionCS.z,UNITY_NEAR_CLIP_VALUE); #else positionCS.z = max(positionCS.z,UNITY_NEAR_CLIP_VALUE); #endif return positionCS; } Varyings vert(Attributes input) { Varyings output; output.uv = input.texcoord; output.positionCS = GetShadowPositionHClip(input); return output; } float4 frag(Varyings input):SV_TARGET { clip(1.0 -_AlphaClip); return 0; } ENDHLSL } //Zbuffer(Depth) Pass Pass { Name\u0026#34;DepthOnly\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;DepthOnly\u0026#34; } ZWrite [_ZWrite] ColorMask 0 Cull [_Cull] HLSLPROGRAM #pragma multi_compile_instancing #pragma multi_compile _ DOTS_INSTANCING_ON #pragma vertex vert #pragma fragment frag struct Attributes { float4 positionOS : POSITION; }; struct Varyings { float4 positionCS : SV_POSITION; }; Varyings vert(Attributes input) { Varyings output = (Varyings)0; output.positionCS = TransformObjectToHClip(input.positionOS.xyz); return output; } half4 frag(Varyings input): SV_TARGET { clip(1.0 - _AlphaClip); return 0; } ENDHLSL } //Main Pass Pass { Name\u0026#34;UniversalForward\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;UniversalForward\u0026#34; } Cull [_Cull] Blend[_SrcBlendMode] [_DstBlendMode] BlendOp [_BlendOp] ZWrite [_ZWrite] Stencil { Ref [_StencilRef] Comp [_StencilComp] Pass [_StencilPassOp] Fail [_StencilFailOp] ZFail [_StencilZFailOp] } HLSLPROGRAM #pragma vertex MainVS #pragma fragment MainFS ENDHLSL } } } ","date":"2025-06-03T15:49:54+08:00","permalink":"https://foth0626.github.io/article/urp-shader-template/","title":"URP Shader 模板"},{"content":"前言 这是一篇记录高二到大三这五年期间的，关于自我的挣扎的，关于自我存在的思考的一篇随笔。关于高中时期，大学初期的个人所思所想已经无法获得原貌，属于现在的我对于我的回忆的一次抢救性考古。\n希冀未来的我不堕于平庸对得起现在我的求索，也希望如果有同样深陷存在主义危机的人读到这片文章时有所帮助。\n正文 先讲讲我的高中背景，一所县中，但是水平算得上不错，也有个省重点的名号，每年也出几个南大，要是运气尚可，那第一便能摘到清华或者北大的桂冠。我并不是正常考上我的高中的，而是通过特长生选拔进的高中，特长生是直接进实验班的（当然，我的中考分数也够我进实验班），不同的高中有着不同的说法，但是这里的实验班指的便是我高中最好的一个班，高一上这个学期，我们尚未分科，期末考便是三门主课加六门副科全考，总分为$3* 150 + 6 *100 = 1050$ ，具体的分数我已记不清楚，只记得大约900分出头，是全校第二。\n分班考的分数已经忘记，不过顺利进入了最终的理科强化班的名单，学校有一条强大的主流，便是学竞赛，不是为了拿奖牌，而是为了强基计划，自主招生这类大学的特殊招生通道。我学的是物理和数学，不过最终数学在高三选拔没进校队，物理进了，最后考了个国二，也是凭这张奖状走了自主招生，进了一个双一流title的一般学校的一般专业。\n以上就是背景，不过呢，想必大家也看出来了，从高一的全校第二，到最后的堪堪进入双一流，我的坠落显得太过夸张，事实也是，最终高考我大约在全班倒数前三。\n大约在高一下到高二这段时间，我喜欢上班里一个女同学，不过呢她后来进的是文科实验班，这段爱恋她应该也知道，不过这并不重要，作为一个引子：在这段无始的爱恋后，我陷入了负面情绪，并引发一个长久的思考，或者说对自己的拷问：人活这一世，最终都以死结尾；人类这个种族，我看不见未来，谁也不知道是否会走向毁灭。牛顿式的机械唯物主义宣告的宇宙犹如一个巨大的机械钟摆，只是无意识地重复着机械的运动，在这种语境下，人类只是无意义的零件，人活着没有意义，无论是死还是活，都是巨大机械钟摆决定好的，既然一切都已注定，那么努力，意义这些概念，便没有存在的价值。\n在这种苍白的感受面前，我最终得出了结论：人活着没有意义。人就应该去死。更重要的是，这个思考给了我一个连锁反应，我从高考中抽离，开始思考高考这件事本身：高考在客观上无疑是一个合理的，符合大多数人，大多数普通人的，现行阶段下最合理的一个制度，但是一想到刷题以争取一个高分的行为，我从中却品味到一丝宗教般的狂热，一种苦行僧似的苦修。我厌恶，甚至说，害怕这种极端的狂热。不仅如此，高考以一种决定论的态度，告诉所有人：高考分数等于大学等级等于未来人生的成功与否。或者说，所有人都以一种决定论的态度裹挟着高考。但唯文凭论是可笑的，所谓的大学文凭，只不过一张四年学费的收据。\n理智告诉我，我还没有完成高考，这种思考无疑是有害的，我应该努力学习解题技巧，争取拿一个好的分数，然后上了大学之后再思考这件事。但是有这样一个自毁的机会摆在我面前，正如站在悬崖边上看着深不见底的深渊，浮现的冲动不是逃离，而是跃下，人总是会因为自己有着自毁的这种自由而兴奋。\n我窃喜着自毁，便选择了摆烂：我开始睡觉，读小说（btw，我看推理的爱好也是这时养成的。），成绩开始可能也开始稳定地下滑。从小养成的唯物思想也向我发出痛苦的哀嚎：上帝已死。是啊，上帝已死，于是没有一个伟大的存在告诉我们，什么是对的，如何获得救赎。我无法也不可能从宗教中得到慰藉。我们从神之子变成了被无情抛弃到荒原的野兽，人的欲望退行回同野兽的生理欲望的同等存在。我们的存在是什么？我们的存在只是一次天雷引起的原始细菌，再在无数次变异中结出的概率论的果吗？\n在这种语境下生活是痛苦的，在无望的夜晚，我曾想过自杀，但最终一句不知从何来的话语浮现于我的脑海：选择死亡本身就是对死亡的背叛。我选择了痛苦地活，至少麻痹地活。所幸，人总是会选择自己寻找出路，我无意间了解到了存在主义，萨特在存在主义即人道主义的演讲中告诉我们：一个意义先于存在诞生的东西——例如钟表，所存在的全部意义只是指示时间——人没有这种先于存在存在的意义，人是 自由 的，人的意义来自于自己的选择。存在主义为我的生存寻得一个借口，我要选择自己的意义。不过这个过程并不顺利，事实是，在约两到三年的时间内，虚无主义和存在主义反复地争夺我思想的高地，我时而觉得人生无意义，时而觉得我应做出自己的选择。现在来看，这多少源于我既缺乏选择自己真正的选择，也缺乏忙碌或者说对自己选择的行动：人总是会在无所事事时选择折磨自己。\n之后便是加缪，我的死亡观诞生于我的思考，但和加缪的思想可谓不谋而合：人总是可以选择何时去死的，在死后便会拥抱永久的宁静，既然如此，何不再活一天看看事情会坏的什么程度呢？\n加缪的名句：人唯一需要严肃考虑的事情只有一件，那便是自杀。\n自杀，或者说去死，可以说是唯一一个只受个人意志，不受任何外界因素影响的事，考虑自杀也就是考虑生命为何而活，即人生意义的问题。\n事实上来说，存在主义已经给我一个解答，所欠缺的无非是一个找寻自己人生意义的结果，可是意义哪是这么好寻找的呢？存在主义是强者的哲学，它把人丢到孤零零的荒野，再逼迫人去寻找一个名为意义的庇护所，还要求人时时刻刻加固这个庇护所。所幸我可能确实找到一个，便是做游戏，这是另外的故事，这里不谈。\n大学生活是混乱的，既保有学校的规矩，又接壤着社会。既有循规蹈矩，大学当高中上的卷王；也有翘课实习的不合群的学生。更何况还有疫情，导致上了许久的网课，我的大一便处于无所事事的状态，人的自毁倾向便在这种时刻滋长，我的自渎频率前所未有的高。一边做着不切实际的梦，一边自甘堕落。所幸，我天生有着反传统，反大众，离群的特质。我最终为了逃离专业内的高中氛围，还是选了个技术学了起来。于是又同时被希望和绝望拉扯着向前走。\n我是幸运的，我关注的up主总是会给我启发，高中时，我习得了做游戏的梦想。现在我又获得了希望。\n关于康米：我希望自身能有自由的发展，需要一个自由平等的社会，这个社会需要思想开明的人民，丰富的物质。所以为了我自己的发展，我应当助力建成这样的社会。即，为了我自己的发展，我需要同样地助别人有平等发展的可能。\n这五年间，在痛苦的长夜中，我瞥视到一抹金黄的黎明，或许在下个五年，或者更久的未来中，我又会有新的苦痛，但新生命的第一声总是啼哭：不要害怕眼泪。况且，人总是要面对自己的，人这一生到底为了什么而活着？在现在就找到一份答案，或许是一种幸运。\n一些其他的话 五年摇摆，换做2000字的短文。放在别人眼里或许也只是无病呻吟。只当记录当下，取悦自己。\n这五年来看过不少鸡汤，或者人生感悟什么的。记录一些，权当回顾，亦作启发。\n“看得见希望时无所畏惧，看不见希望时就应该放弃吗？” 在黑暗的时代，群星是否也应该熄灭？\n有一个超越时空的回答是：“星星之火，可以燎原。”\n西方有一条重要的世俗，或者主流，寻找自己的热情。但热情这种东西不总是能有的。\n3B1B在毕业典礼中给出的答案是：行动先于热情。尝试-成功-成就感，行动本身先于动力。\n要做理想主义者，是需要实干和牺牲的。不要成为空想主义者。——纪念特蕾西娅\n等待，思考，斋戒——《悉达多》\n","date":"2025-05-28T02:28:21+08:00","permalink":"https://foth0626.github.io/article/one-five-years/","title":"高二到大三的五年：从虚无主义到存在主义"},{"content":"前言 PBR在12年提出了Disney Principled BRDF，以简洁且一致的工作流和强大的表现效果被各大引擎和DCC快速支持，并成为了业界公认的标准。本文将依据Disney 发表的论文 Physically-Based Shading at Disney ，作Disney Principled BRDF的一个简要笔记并使用HLSL语言实现。\n本人才疏学浅，如有错误，敬请指正，本人不胜感激。\nDisneyBRDF 的来源 Disney BRDF 使用的是 微表面模型，即\n$$ f(l,v) = diffuse + \\frac{D(\\theta_h)F(\\theta_d)G(\\theta_l,\\theta_v)}{4 \\cos\\theta_l\\cos\\theta_v} $$其中，diffuse未知，通常用 lambert 模型表述，而高光项则包含 $D$,$F$,$G$ 三项，分别表示法线分布函数，菲涅尔反射系数，几何遮蔽函数。\n关于 $h$ ，即半角向量，虽然在运算中，它仅仅是 $lightDir$, $viewDir$ 之和的归一化向量（即$\\frac{l + v}{ |l + v| }$）。但它有着更深刻的含义：如果给定光线方向 $l$ 和视线方向 $v$ 能够发生镜面反射，说明存在微表面，且这些微表面的法线与半角向量 $h$ 的方向相同。所以对于 $D$ 项，我们使用半角向量而不是 pixel 的 normal。\n值得一提的是，Disney 指出： 对于未明确采用微表面模型的PBR，仍可以解读为微表面模型，只要包含 $D$ ，$F$ 项以及可以被看作 $G$ 项的某种因子。微表面模型与别的模型的最大区别是是否显式地包含 $\\frac{1}{4 cos\\theta_l cos\\theta_v}$ 。对于未包含该因子的模型，可通过提取D和F因子后，将模型乘以 $4cos\\theta_lcos\\theta_v$ 来推导其隐含的阴影因子。\nDisney使用了 \u0026ldquo;MERL 100\u0026rdquo; 数据库记录的材质数据和DisneyBRDF进行比较，以确保自己的材质是真实可信的。\u0026ldquo;MERL 100\u0026quot;记录了100个各向同性的材质，详细记录了他们的数据。Disney 对于MERL100数据库的观察我们不提，可以参考毛星云大神的文章【基于物理的渲染（PBR）白皮书】（三）迪士尼原则的BRDF与BSDF相关总结。\nDisney “principled” BRDF 解析与实现 diffuse diffuse是次表面散射的一个抽象/简化，所以很多模型会加上菲涅尔项使其更加物理，disney的公式形似：\n$$(1 − F(\\theta_l))(1 − F(\\theta_d ))$$使用两个菲涅尔是为了保持Helmholtz互易（即光路可逆性）。\n$$f_d = \\frac{baseColor}{\\pi}(1+F_{D90}-1)(1-\\cos\\theta_l)^5(1 + (F_D90-1)(1-\\cos\\theta_v)^5)$$$$F_{D90} = 0.5 + 2 roughness \\cos^2\\theta_d $$$\\theta_d$ 是光线和半角向量的夹角。\n这个模型和MERL100拟合的相当优秀，并且艺术友好。\n次表面项使用另一个diffuse模型进行拟合，不过由于并不是真正的模拟光的次表面散射，所以表现能力只能说聊胜于无，完整的次表面散射应该参考2015年的Disney BSDF，不过这就不是实时渲染的话题了。\nD 基于对于多个模型的观察，尤其是GGX（Trowbridge-Reitz）分布和Berry分布。Disney在这篇文章中提出了GTR（Generalized-Trowbridge-Reitz）模型。\n$$D_{GTR}= c/(\\alpha^2\\cos^2\\theta_h+\\sin^2\\theta_h)^\\gamma$$补：完整公式为： $$D_{GTR}(\\theta_h) = \\frac{(\\gamma-1)(\\alpha^2-1)}{\\pi(1-(\\alpha^2)^{1-\\gamma})} \\frac{1}{(1 + (\\alpha^2-1)\\cos^2\\theta_h)^\\gamma}$$$$\\phi_h = 2\\pi\\xi_1$$$$\\cos\\theta_h = \\sqrt{\\frac{1-[(\\alpha^2)^{1-\\gamma}(1-\\xi_2)+\\xi_2]^{\\frac{1}{1-\\gamma}}}{1-\\alpha^2}}$$ 其中，$\\xi$ 为采样随机数， $\\phi_h$ 为 半角的角度。\n碎碎念：现在连希腊字母都不会念了，高中学的物竞都还给老师了，唉\n当 $\\gamma$ 为2时等效GGX，$\\gamma$ 为1时等效Berry分布，当 $\\gamma$ 为10时，拟合到Beckmann分布。随着$\\gamma$的增大，高光尾部逐渐缩短。\nD项使用了两个Specular lobe，主波瓣使用GTR2（GGX），副波瓣（清漆层）使用GTR1。并且主波瓣支持各向异性和金属，而副波瓣不支持。\n使用$a = roughness^2$ 映射，达到更好的线性变化的外观。\n关于缩放常数c，为了满足能量守恒，因此整个函数应当积分为1，需要一个常数C缩放，对于不同的 $\\gamma$ 会有不同的C，可以自己积分得出（我不会算*）。\nF 经典的Schlick近似。\n$$F_{Schlick} = F_0 + (1 − F_0 )(1 − cosθ_d)^5$$G 没有被masking和shadowing的比例。不完全物理，参考了艺术家的意见进行了修改。\n开发经验 材质可以在不同的环境下进行一致的响应。艺术家们可以实时编辑所有参数并立刻看到结果，并且可以获得和最终的展示效果一样的模型，这使得艺术家无需在照明阶段返工，并获得了一致的高质量渲染结果。统一模型还带来了一个优势：可以通过保存一组参数预设来获得一个简单的材质库。\nOther 微表面分布函数 $D(\\theta_h)$是关于半角向量 h 的分布函数。\n为了保持物理合理性，其在半球上的投影面积积分必须为 1： $\\int_{\\Omega} D(\\theta_h) \\cos \\theta_h , d\\omega = 1$ 即积分考虑了 $\\cos \\theta_h​$ 的投影因子。\n为了重要性采样（importance sampling），可以将采样概率密度函数选为：$\\text{pdf}_h = D(\\theta_h) \\cos \\theta_h$ 。（我也不会算）\n各向异性的0.9主要用于限制了长宽比为 10:1\nsheen由一个额外的BRDF lobe模拟。\nImplementation 我参考Disney BRDF Explorer 的官方实现 Copy 了一份HLSL实现:DisneyBRDF.\n碎碎念一下: 一开始我的实现用了 PI 这个宏，这个宏被Unity定义过，所以引入到Unity Shader中就会报错，然后用了 const float MY_PI = 3.1415926535 一个const变量，结果引入到UnityShder后不知道为什么 MY_PI 变成0了，搞的整个材质爆白，我还挂着Bloom给我闪瞎了，瞎试了半天才想到抓帧才发现这个离谱Bug（）。最后又用回宏 #define MY_PI 怀疑是Shaderlab的问题（总之fuck Unity），以后有时间探究一下底层实现（）。\n洁尔佩塔的衣服使用了DisneyBRDF。（头发是我在调球壳法线，无视就好）\n","date":"2025-05-27T22:54:21+08:00","image":"https://foth0626.github.io/article/disney-pbr/aglina_hu_75b5ffe63090d507.png","permalink":"https://foth0626.github.io/article/disney-pbr/","title":"迪士尼原则的BRDF"},{"content":"本文为RTR4 18章管线优化总结。\nDonald Knuth——“We should forget about small efficiencies, say about 97% of the time:Premature optimization is the root of all evil.”\n图形渲染是基于流水线架构的，因此效率取决于管线中的最慢的一个步骤。值得注意的是，当最慢的步骤无法继续优化时，可以将其他步骤使用额外的计算提高画面的质量。\nKNOW YOUR ARCHITECTURE\n优化是需要针对特定硬件而言的。\nMEASURE , MEASURE , MEASURE.\n实际的性能测试才能反映你的优化是否有效。\n性能瓶颈定位 想要进行性能优化，首先得定位性能瓶颈在哪。\n应用阶段测试 发送让GPU很少工作或根本不工作的数据。或者使用一个空驱动程序。（这个方法可能会导致一些因为驱动程序本身导致的问题。） 降低CPU时钟频率。如果性能降低，那么可以说明程序至少在某种程度上与CPU绑定。GPU也可以使用类似的降频（underclock）方法。 几何处理阶段 这个部分是最难测试的阶段，因为其他一些阶段的工作负载也会发生相应的变化。\n几何处理阶段的瓶颈通常出现在顶点获取和顶点处理。\n顶点获取的测试方式：\n增大顶点格式的大小。例如：在每个顶点上发送一些额外的纹理坐标用来增大顶点的数据。 顶点处理由顶点着色器（Vertex Shader）完成。通过让Vertex Shader 变得更长更复杂可以测试瓶颈。但需要担心编译器的优化导致额外指令的无效。几何着色器和曲面细分着色器也会在顶点处理阶段导致额外的性能开销。通常来说，可以使用控制变量法，可以帮助我们确定这些元素是否是性能瓶颈。 光栅化阶段 光栅化一共包含两个阶段，三角形设置和三角形遍历。三角形设置会计算三角形的微分，边界方程和其他数据，并将这些数据用于三角形遍历。\n在如生成shadow map 时，由于像素着色器相当简单，所以可能导致光栅化阶段成为瓶颈。 如果场景内的微小三角形过多，会因为三角形会以2 $\\times$ 2 的四边形为一组进行光栅化，导致辅助像素的数量过多，出现 overshading 的情况。\n为了确定光栅化阶段是否为瓶颈，可以通过增加Vertex Shader 和 Fragment Shader 的大小，如果时间不变，那么瓶颈可能位于光栅化阶段。 像素处理阶段 可以通过改变屏幕分辨率来进行测试，但是如果软件系统设计良好，低分辨率会同时导致使用简化模型，导致几何处理的负载变化。还可能会影响三角形遍历、深度测试、混合和纹理访问等方面的开销。\n可以增大Fragment Shader的复杂度，并观察渲染时间的变化。 此外，还可以将像素着色器简化到最少（这在Vertex Shader 中通常很难做到）。 纹理缓存未命中导致的开销也是十分高的，如果使用一个 1 $\\times$ 1 的纹理导致了性能的提高，那么纹理访问是一个瓶颈。 合并阶段测试 这个阶段会进行深度测试和模板测试，并进行混合操作。这个阶段可能会成为后处理 pass、阴影、粒子系统渲染的瓶颈。\n改变这些缓冲区的输出 bit 深度是一种改变此阶段带宽成本的方法,这样可以帮助我们查看这个阶段是否会成为瓶颈。 优化手段 应用阶段 内存问题 在很多年前,算术指令的数量是衡量算法效率的关键指标,而如今则是内存访问模式(memory access pattern) 。处理器的速度在过去的很多年间快速增长,而 DRAM 的数据传输速度则增长有限,因为 DRAM会受到引脚数量的限制。 因此，尽量确保需要读取的数据在缓存（cache）上，可以显著的增加程序的效率。从CPU的寄存器，到L1,L2,L3级缓存，再到DRAM（dynamic random access memory , 即大家常说的内存），再到SSD和HDD，再到云盘/网盘/服务器数据。自顶向下，呈现出从昂贵到廉价，从小容量到大容量，从高速到低速的趋势，值得一提的是，高速到低速的差距通常而言是指数级别的。 内存中的相邻位置通常而言会被依次访问（空间局部性）。而同一位置往往也会被重复访问（时间局部性）。\n代码中按顺序访问的数据,也应当按顺序存储在内存中。 避免间接指针、跳转和函数调用 将经常使用的数据结构和缓存行大小的倍数进行对齐，可以显著提升性能。 在启动的时候,为相同大小的对象分配一个较大的内存池,然后使用我们自行编写的分配程序和释放程序来管理这个内存池中的内存。 图形API调用 状态改变 一个常见的图形操作是对管线进行准备来绘制一个网格，这个操作会涉及一些状态改变，例如：设置着色器和uniform变量，附加的纹理，更改混合状态，更改所使用的颜色缓冲等。提高应用程序性能的一个主要方法是将具有相似渲染状态的对象进行分组，从而最小化状态更改所带来的开销。 不同类型的状态改变有着不同的开销，这里是一个例子：\nGPU 的渲染模式和计算着色器模式之间进行切换 渲染目标(render target)(framebuffer 对象),大约 60k/秒。 着色器程序,大约 300k/秒。 混合模式(ROP),例如透明度。 纹理绑定,1.5M/秒。 顶点格式。 统一缓冲区对象(uniform buffer object,UBO)绑定。 顶点绑定。 统一变量更新,大约 10M/秒。 可以对要显示的对象按照着色器类型进行分组,然后按照使用的纹理进行分组,以此类推(按照成本顺序)进行排序分组。按照状态进行排序有时会被称为批处理(batching) 。 另一种策略是重构对象的数据组织方式。如使用纹理数组，或者在API支持的情况下使用无绑定纹理。\n由于对着色器的修改成本比修改uniform变量/纹理的开销高得多。因此同一种材质的变化可以使用\u0026quot;if\u0026quot;进行切换。也可以通过共享一个着色器来实现更大的批次，不过，更复杂的shader也会导致性能下降，所以实事求是地测试是唯一万无一失的方法。\n将多个uniform 变量打包成一个组比绑定单个统一缓冲区对象的效率要高得多，这在DX中称为Constant Buffer。\n在每次 draw call 之后都返回一个基本状态可能会变得成本很高。例如:当我们要绘制一个对象时,我们可能会假设状态 X默认是关闭的。实现这一目标的一种方法是“启用( X );绘制( M1​); 禁用( X) ”,然后再“启用( X);绘制( M2); ​禁用( X) ”,即在每次绘制操作之后都会恢复初始状态。然而,在两次 draw call 之间对状态进行再次设置很可能会浪费大量时间,即使它们之间并没有发生实际的状态改变。\n合并和实例化 一个被三角形填充的网格,渲染起来要比大量小而简单的网格更加高效。这是因为无论这个图元的大小如何,每个 draw call 都有固定的成本开销(即处理图元的成本) 。 早在 2003 年,Wloka 就指出,每个批次仅仅绘制两个(尺寸相对较小的)三角形,其效率距离GPU 的最大吞吐量还差 375 倍。对于那些由许多小而简单的物体所组成的场景,这些物体只包含很少的几个三角形,其渲染性能完全受 API 的 CPU 限制,GPU 的能力再强也没法增加渲染效率。也就是说,这些 draw call 在 CPU 上的处理时间,要大于 GPU 实际渲染网格所需的时间,即 GPU 没有被充分利用。 减少 draw call 次数的一种方法是将多个物体合并到一个网格中,这样就只需要一次 draw call 来渲染该集合即可。因为这些静态物体在同一个网格中是没有区别的，物体选择是一个合并导致的问题。一个典型的解决方案是,在网格的每个顶点中都存储一个对象标识符来进行标记。 另一种最小化应用程序和API成本的方法是使用Instancing。即在一次draw call中对同一个物体绘制多次。这通常是指定一个基础模型，并提供一个单独的数据结构，并在其中包含了每个特定示例的所需要的信息。除了位置和朝向之外，还可以指定其他的如树叶的颜色或者由风所引起的曲率变化等等任何可以被shader用来影响模型的数据。LOD也可以与Instance技术一起使用，\n几何处理阶段 高效的三角形网格存储方式、模型简化和顶点数据压缩 截锥体剔除和遮挡剔除 烘焙以减少运行时计算。 光栅化阶段 背面剔除 像素处理阶段 避免过小的三角形，较小的三角形会生成大量部分覆盖的的四边形，而且，那些只覆盖几个像素的纹理网格通常会导致warp的占用率较低，导致纹理采样的延迟的隐藏效果较差。 而如果是需要使用大量寄存器的复杂着色器，也会导致同一时间内的线程数量减少，这种情况被称为寄存器压力（register pressure）。 使用原生的纹理格式和像素格式，从而避免格式之间的转换。 只加载需要的mipmap层级。 使用纹理压缩技术。 通过LOD技术，对于不同的距离使用不同的fragment shader。可以简化远处的模型的计算，甚至可以简化高光甚至完全移除高光。 GPU的early-z测试可以提前剔除不可见的片元。 帧缓冲 压缩颜色精度，如从16bit压缩到8bit。或者使用Yuv有损压缩。 多处理 多处理系统分为multiprocessor pipelining（多处理器流水线），即时间并行（temporal parallelism），以及parallel processing（并行处理），空间并行（spatial parallelism）。在理想情况下n个处理器均可提升 n倍的处理速度。\n时间并行 举例：一个应用程序分为APP,CULL,DRAW三个阶段。\nAPP：APP 阶段是流水线中的第一个阶段,它控制着其他的后续阶段。在这个阶段中,开发人员可以添加额外的代码,例如进行碰撞检测等。同时 APP 阶段还会对视点进行更新。 CULL：视锥体剔除，LOD选择，状态排序，生成渲染的所有物体的列表。 DRAW：获取CULL的物体列表，执行图形调用，向GPU发送数据。 这种技术可以提高吞吐量与渲染速度，但是从轮询用户操作，到显示最终的图像的操作的延迟被加大了。\n空间并行 使用这种并行处理必须需要程序的任务必须拥有并行性，可以将任务并行地进行，每个处理器都负责处理一个工作，当所有的CPU完成各自的工作时，将结果合并。 比如一个单CPU需要30ms完成的任务，可以分解成3个CPU耗费10ms完成，并将最终的结果合并一起发送到GPU绘制。这种情况下，会显著地降低任务的延迟。\n基于任务的多处理 考虑到许多 CPU 上都有很多核心,现在的技术趋势是使用基于任务的多处理方法。就像是可以为一个并行化进程创建多个任务(也称为作业)一样,这种思想也可以扩展到流水线上。由任何核心生成的任何任务,首先都会被放入工作池中,任何处于空闲状态的处理器都会获取一个任务来进行处理。转换为多处理的一种方法是,获取应用程序的工作流程,并确定其中哪些系统需要依赖于其他系统。\n注意到有：有时 GPU 内核也会处于空闲状态,例如在生成阴影贴图或者进行深度 prepass 的时候,很多 GPU 核心并未被充分利用。在这样的空闲时间中,可以使用计算着色器来计算其他任务。\n","date":"2025-04-21T10:34:19+08:00","permalink":"https://foth0626.github.io/article/performance-optimization/","title":"a brief discussion of performance optimization"},{"content":"本文章为SAST.Graphics组授课文档记录 引用资料：\n毛星云：PBR白皮书 LearnOpenGL-CN 百人计划-5.1 PBR基础 PBR核心理论 基于物理的渲染（Physically Based Rendering，PBR）是指使用基于物理原理和微平面理论建模的着色/光照模型，以及使用从现实中测量的表面参数来准确表示真实世界材质的渲染理念。它指的是在不同程度上使用与现实世界的物理原理更相符的基本理论所构成的渲染技术的集合。正因为基于物理的渲染目的便是使用一个中更符合物理学规律的方式来模拟光线，因此PBR的渲染效果总是比实际上看上去要更真实一些。除此之外，因为它与物理性质的相似，所以艺术家可以直接基于物理参数来编写材质，而不需要依据经验和反复试错使光照效果看起来正常。\n寒霜(Frostbite)引擎在SIGGRAPH 2014的分享《Moving Frostbite to PBR》中提出，基于物理的渲染的范畴，由三部分组成：\n基于物理的材质（Material） 基于物理的光照（Lighting） 基于物理适配的摄像机（Camera) 完整的这三者，才是真正完整的基于物理的渲染系统。\n值得注意的是，PBR仍然只是对现实世界的一种近似，所以它被称为基于物理的渲染（Physically Based Rendering），而不是物理渲染（Physically Rendering）！ 微平面理论（Microfacet Theory） :微平面理论是将物体表面建模成做无数微观尺度上有随机朝向的理想镜面反射的小平面（microfacet）的理论。在实际的PBR工作流中，这种物体表面的不规则性用粗糙度贴图或者高光度贴图来表示。 能量守恒（Energy Conservation） :出射光线的能量永远不能超过入射光线的能量。随着粗糙度的上升镜面反射区域的面积会增加，作为平衡，镜面反射区域的平均亮度则会下降。 菲涅尔反射（Fresnel Reflectance） :光线以不同角度入射会有不同的反射率。相同的入射角度，不同的物质也会有不同的反射率。万物皆有菲涅尔反射。F0是即 0 度角入射的菲涅尔反射值。大多数非金属的F0范围是0.02~0.04，大多数金属的F0范围是0.7 ~ 1.0。 线性空间（Linear Space） :光照计算必须在线性空间完成，shader中输入的gamma空间的贴图比如漫反射贴图需要被转成线性空间，在具体操作时需要根据不同引擎和渲染器的不同做不同的操作。而描述物体表面属性的贴图如粗糙度，高光贴图，金属贴图等必须保证是线性空间。 色调映射（Tone Mapping） :也称色调复制（tone reproduction），是将宽范围的照明级别拟合到屏幕有限色域内的过程。因为基于HDR渲染出来的亮度值会超过显示器能够显示最大亮度，所以需要使用色调映射，将光照结果从HDR转换为显示器能够正常显示的LDR。 物质的光学特性（Substance Optical Properties）: 现实世界中有不同类型的物质可分为三大类：绝缘体（Insulators），半导体（semi-conductors）和导体（conductors）。在渲染和游戏领域，我们一般只对其中的两个感兴趣：导体（金属）和绝缘体（电解质，非金属）。其中非金属具有单色/灰色镜面反射颜色。而金属具有彩色的镜面反射颜色。即非金属的F0是一个float。而金属的F0是一个float3。 微表面理论 光与非光学平坦表面的交互原理 大多数真实世界的表面不是光学上光滑的，但是具有比光波长大得多但比像素小的尺度的不规则性。 这种微观几何（microgeometry）变化导致每个表面点反射（和折射）不同方向的光：材质的部分外观组成是这些反射和折射方向的聚合结果。 光在与非光学平坦表面（Non-Optically-Flat Surfaces)的交互时，非光学平坦表面表现的像一个微小的光学平坦表面的大集合。表面上的每个点都会以略微不同的入射光反射，而最终反射的表面外观是许多不同取向的点的聚合结果。 在微观尺度上，表面越模糊，反射越模糊，因为微表面与整个宏观表面取向的偏离更强。\n出于着色的目的，我们通常会使用统计方法去处理这种微观几何现象，并视为表面上的点在多个方向上反射和折射光线。\n有关微观几何对反射率影响的数学分析，被称为微表面理论（microfacet theory），许多 BRDF 模型都是建立在这个理论之上的。这个工具最初是由光学界的研究人员提出的，1977 年由 Blinn引入了计算机图形学，1981 年由 Cook 和 Torrance 再次引入。\n该理论的基础是，将微观几何建模为一组微表面的集合。每个微表面都是平坦的，它具有一个微表面法线 $m$ ；这些微表面会根据 micro-BRDF $f_\\mu(l,v,m)$ 来对光线进行分别反射，将所有微表面的反射率加起来，就是整个表面的 BRDF。通常的做法是将每个微表面都当成一个完美的菲涅尔镜面，这会产生镜面的微表面 BRDF，用于模拟表面反射。\n图 微平面粗糙度对材质外观的影响。（图片来自Moving Frostbite to PBR，SIGGRAPH 2014）\n对于反射光线，它的行为很好理解，但是折射进表面的光会发生什么变化呢？这取决于物质本身的特性\n对于 金属 ,折射光会立刻被吸收，这是因为金属中有大量的自由电子。 对于非金属（电介质或者绝缘体），一旦光在其内部折射，就表示为常规的参与介质，表现出吸收和散射两种行为。 漫反射和次表面散射本质相同 漫反射本质也是折射光的次表面散射的结果。唯一的区别是观察尺度，如果散射距离相对于观察尺度（像素采样大小）的大小非常小，那么次表面散射可以直接近似为漫反射。\n能量守恒 渲染方程（The Rendering Equation） 渲染方程描述了光能在场景中的流动，是渲染中的不可感知方面的最抽象的表示。根据光学的物理学原理，渲染方程在理论上给出了一个完美的解，而各种各样的渲染技术，只是这个理想结果的近似。\n对于某一点的渲染方程，可以表示为\n$$L_o = L_e + \\int_{\\Omega} f_r \\cdotp L_i \\cdotp (\\omega_i\\cdot n)\\cdot d\\omega_i$$ $L_o$ 是p点的出射光亮度。 $L_e$ 是p点发出的光亮度。 $f_r$ 是p点入射方向到出射方向光的反射比例，即BxDF，一般为BRDF。 $L_i$ 是p点入射光亮度。 $(\\omega_i \\cdotp n)$ 是入射角带来的入射光衰减 $\\int_{\\Omega} \u0026hellip;d w_i$ 是入射方向半球的积分。 在实时渲染中，我们常用的反射方程（The Reflectance Equation）则是渲染方程的一个简化版本，或者说一个特例。\n$$L_o =\\int_{\\Omega} f_r \\cdotp L_i \\cdotp (\\omega_i \\cdotp n) \\cdotp d \\omega_i$$\n能量守恒 概念：出射光线的能量 永远不大于 入射光线的能量\n表现：随着粗糙度的上升镜面反射区域的面积会增加，作为平衡，镜面反射区域的平均亮度则会下降。\n如何确保能量守恒？\n使用反射方程：\n$$L_o =\\int_{\\Omega} f_r \\cdotp L_i \\cdotp (\\omega_i \\cdotp n) \\cdotp d \\omega_i$$ 简单理解：出射光线强度 = 入射光强度 * 入射角度衰减 * 反射比例\n$L_i$ ：入射光强度 $(\\omega_i \\cdotp n)$ : 入射角度带来的入射光衰减 $f_r$ : 反射比例 如何求反射比例？：BRDF !\nBxDF BxDF 一般而言是对BRDF、BTDF、BSDF、BSSRDF等几个双向分布函数的一个统一表示。 其中，BSDF可以看作BRDF和BTDF更一般的形式，而且BSDF = BRDF + BTDF。 BSSRDF和BRDF的不同之处在于，BSSRDF可以指定不同的光线入射位置和出射位置。 BRDF最为简单，也最为常用。因为游戏和电影中的大多数物体都是不透明的，用BRDF就完全足够。而BSDF、BTDF、BSSRDF往往更多用于半透明材质和次表面散射材质。\nBRDF（Bidirectional Reflectance Distribution Function） Wikipedia\n双向分布反射函数，$f_r(\\omega_i,\\omega_r)$ 是四个实变量的函数，用于定义光源的光如何从不透明表面反射。每个方向 $\\omega$ 由天顶角和方位角确定，所以是四个参数的函数。BRDF描述了出射光方向的radiance和入射到表面的irradiance的比例。\n值得一提的是，图形学中的BRDF通常来说应该是SVBRDF（Spatially Varying Bidirectional Reflectance Distribution Function）或者SBRDF（Spatially Bidirectional Reflectance Distribution Function），即 $f_r(\\omega_i,\\omega_r, x)$ ， $x$ 是物体表面的2D位置。\n严格来说，同样使用 $\\omega_i$ 和 $\\omega_o$ 作为输入参数的Blinn-Phong 光照模型也被人认为一个BRDF模型，但是 Blinn-Phong 模型并没有遵循能量守恒定律，因此它不是基于物理的渲染。\n基于物理的BRDF 基于物理的BRDF还有一些性质：\nBRDF的值总是大于等于零的 遵从亥姆霍兹光路可逆性（Helmholtz Recoprpcity Rule），即光路相反值不变。 能量守恒，对于所有的BRDF的在整个球面的积分总是小于1 线性特征，表面上某一点的全部反射辐射度可以简单地表示为各BRDF反射辐射度之和 Cook-Torrance 反射率方程 现在有好几种BRDF都能得出对于物体表面对于光的反应，但是几乎所有实时渲染管线都是使用的同一套模型： Cook-Torrance BRDF 模型。\n$$f_r = k_d f_{lambert} + k_s f_{cook-torrance}$$Cook-Torrance BRDF 模型兼有漫反射和镜面反射两个部分， $k_d$ 就是入射光线中的折射部分占的比例，而 $k_s$ 是反射部分的比例。 其中， $f_{lambert} = \\frac{c}{\\pi}$ ，表示的是表面颜色，除以 $\\pi$ 是为了对漫反射进行归一化，因为BRDF的积分方程受 $\\pi$ 影响。\n目前存在着许多不同类型的模型来实现BRDF的漫反射部分，大多看上去都相当真实，但是相应的运算开销也非常的昂贵。不过按照Epic公司给出的结论，Lambertian漫反射模型已经足够应付大多数实时渲染的用途了。\n而镜面反射 $f_{cook-torrance}$ 则更加高级一些，形式如下：\n$$f_{cook-torrance} = \\frac {DFG}{4(\\omega_o \\cdotp n)(\\omega_i \\cdotp n)}$$Cook-Torrance BRDF的镜面反射部分包含三个函数，此外分母部分还有一个标准化因子 。字母D，F与G分别代表着一种类型的函数，各个函数分别用来近似的计算出表面反射特性的一个特定部分。三个函数分别为法线分布函数(Normal Distribution Function)，菲涅尔方程(Fresnel Rquation)和几何函数(Geometry Function)：\n法线分布函数：估算在受到表面粗糙度的影响下，朝向方向与半程向量一致的微平面的数量。这是用来估算微平面的主要函数。 几何函数 ：描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。 菲涅尔方程：菲涅尔方程描述的是在不同的表面角下表面所反射的光线所占的比率。 法线分布函数 法线分布函数D表明的是从统计学上近似的表示的与向量相同方向的微平面的比率。目前有很多NDF都可以从统计学上估算微平面的总体取向度，只要给定一些粗糙度的参数。我们在这里要用到的是Trowbridge-Reitz GGX:\n$$NDF_{GGXTR}(n,h,\\alpha) = \\frac{\\alpha^2} {\\pi((n \\cdotp h)^2(\\alpha^2 -1)+1)^2}$$其中， $n$ 是表面法线， $h$ 是半程向量， $\\alpha$ 是表面粗糙度。\n我们可以得到如下结果\n当粗糙度很低（也就是说表面很光滑）的时候，与半程向量取向一致的微平面会高度集中在一个很小的半径范围内。由于这种集中性，NDF最终会生成一个非常明亮的斑点。但是当表面比较粗糙的时候，微平面的取向方向会更加的随机。你将会发现与_h_向量取向一致的微平面分布在一个大得多的半径范围内，但是同时较低的集中性也会让我们的最终效果显得更加灰暗。\n1 2 3 4 5 6 7 8 9 10 11 float D_GGX_TR(vec3 N, vec3 H, float a){ float a2 = a*a; float NdotH = max(dot(N, H), 0.0); float NdotH2 = NdotH*NdotH; float nom = a2; float denom = (NdotH2 * (a2 - 1.0) + 1.0); denom = PI * denom * denom; return nom / denom; } 几何函数 几何函数从统计学上近似的求得了微平面之间互相遮蔽的比例，这种相互遮蔽会损耗光线的能量。与NDF类似，几何函数使用一个材料的粗糙度参数作为输入参数，粗糙度较高的表面的微平面相互遮蔽的概率就越高。\n关于几何函数的详细论述，见毛星云PBR白皮书（5）：几何函数总结\n我们使用的是GGX和 Schlick-Beckmann 近似的结合体，因此也称为 Schlick-GGX\n$$G_{SchlickGGX}（n,v,k）= \\frac{n \\cdotp v}{(n \\cdotp v)(1-k)+k}$$ 其中 ，$k_{direct} = \\frac{(\\alpha + 1)^2}{8}$ ，直接光照。 $k_{IBL} = \\frac{\\alpha^2}{2}$ ，屏幕空间光照。\n为了有效的估算几何部分，需要将观察方向（几何遮蔽(Geometry Obstruction)）和光线方向向量（几何阴影(Geometry Shadowing)）都考虑进去。我们可以使用史密斯法(Smith’s method)来把两者都纳入其中：\n$$G(n,v,l,k)= G_{sub}(n,v,k)G_{sub}(n,l,k)$$可以得到这样的效果。\n几何函数是一个值域为[0.0, 1.0]的乘数，其中白色或者说1.0表示没有微平面阴影，而黑色或者说0.0则表示微平面彻底被遮蔽。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 float GeometrySchlickGGX(float NdotV, float k){ float nom = NdotV; float denom = NdotV * (1.0 - k) + k; return nom / denom; } float GeometrySmith(vec3 N, vec3 V, vec3 L, float k){ float NdotV = max(dot(N, V), 0.0); float NdotL = max(dot(N, L), 0.0); float ggx1 = GeometrySchlickGGX(NdotV, k); float ggx2 = GeometrySchlickGGX(NdotL, k); return ggx1 * ggx2; } 菲涅尔方程 菲涅尔（发音为Freh-nel）方程描述的是被反射的光线对比光线被折射的部分所占的比率，这个比率会随着我们观察的角度不同而不同。当光线碰撞到一个表面的时候，菲涅尔方程会根据观察角度告诉我们被反射的光线所占的百分比。利用这个反射比率和能量守恒原则，我们可以直接得出光线被折射的部分以及光线剩余的能量。\n当垂直观察的时候，任何物体或者材质表面都有一个基础反射率(Base Reflectivity)，但是如果以一定的角度往平面上看的时候所有反光都会变得明显起来。你可以自己尝试一下，用垂直的视角观察你自己的木制/金属桌面，此时一定只有最基本的反射性。但是如果你从近乎90度（译注：应该是指和法线的夹角）的角度观察的话反光就会变得明显的多。如果从理想的90度视角观察，所有的平面理论上来说都能完全的反射光线。这种现象因菲涅尔而闻名，并体现在了菲涅尔方程之中。\n菲涅尔方程是一个相当复杂的方程式，它本质上是麦克斯韦方程组的一个特殊解。不过幸运的是菲涅尔方程可以用Fresnel-Schlick近似法求得近似解：\n$$F_{Schlick}(h,v,F_0) = F_0 + (1-F0)(1-(h \\cdotp v))^5$$$F_0$ 表示平面的基础反射率，它是利用所谓的折射指数（Indices of Refraction ,IOR）计算得出的。然后正如下图所示，我们朝这略射角的方向上看时，反光越来越强。\n但是有一个问题：Fresnel-Schlick 近似仅仅是对非金属表面做了定义，对于金属表面，我们不能通过计算得出 $F_0$ 所以通常，我们会预计算出 $F_0$ 使用一张纹理存储。\n完整公式 $$L_o(p,\\omega_o) = \\int_\\Omega (k_d \\frac{c}{\\pi}+k_s \\frac{DFG}{4(\\omega_o \\cdotp n)(\\omega_i\\cdotp n)})L_i(p,\\omega_i) n \\cdotp \\omega_{i} d \\omega_i$$迪士尼原则的BxDF 基于物理的渲染（Phyasically Based Rendering )技术，自从迪士尼在SIGGRAPH 2012上提出了著名的“迪士尼原则的BRDF（Disney Principled BRDF）后，由于高度的易用性和方便的的工作流，已经被电影和游戏业界广泛使用。\n迪士尼动画工作室则是这次PBR革命的重要推动者。迪士尼的Brent Burley于SIGGRAPH 2012上进行了著名的talk《Physically-based shading at Disney》，提出了迪士尼原则的BRDF（Disney Principled BRDF）， 由于其高度的通用性，将材质复杂的物理属性，用非常直观的少量变量表达了出来（如金属度metallic和粗糙度roughness），在电影业界和游戏业界引起了不小的轰动。从此，基于物理的渲染正式进入大众的视野。\n迪士尼原则的BRDF 在2012年迪士尼原则的BRDF被提出之前，基于物理的渲染都需要大量复杂而不直观的参数，此时PBR的优势，并没有那么明显。在2012年迪士尼提出，他们的着色模型是艺术导向（Art Directable）的，而不一定要是完全物理正确（physically correct）的 ，并且对微平面BRDF的各项都进行了严谨的调查，并提出了清晰明确而简单的解决方案。\n迪士尼原则的BRDF（Disney Principled BRDF）核心理念如下：\n应使用直观的参数，而不是物理类的晦涩参数。 参数应尽可能少。 参数在其合理范围内应该为0到1。 允许参数在有意义时超出正常的合理范围。 所有参数组合应尽可能健壮和合理。 以上五条原则，很好地保证了迪士尼原则的BRDF的易用性。\nDisney Principled BRDF参数 以上述理念为基础，迪士尼动画工作室对每个参数的添加进行了把关，最终得到了一个颜色参数（baseColor）和下面描述的十个标量参数：\nbaseColor（基础色）：表面颜色，通常由纹理贴图提供。 subsurface（次表面）：使用次表面近似控制漫反射形状。 metallic（金属度）：金属（0 =电介质，1=金属）。这是两种不同模型之间的线性混合。金属模型没有漫反射成分，并且还具有等于基础色的着色入射镜面反射。 specular（镜面反射强度）：入射镜面反射量。用于取代折射率 specularTint（镜面反射颜色）：对美术控制的让步，用于对基础色（base color）的入射镜面反射进行颜色控制。掠射镜面反射仍然是非彩色的。 roughness（粗糙度）：表面粗糙度，控制漫反射和镜面反射。 anisotropic（各向异性强度）：各向异性程度。用于控制镜面反射高光的纵横比。（0 =各向同性，1 =最大各向异性） sheen（光泽度）：一种额外的掠射分量（grazing component），主要用于布料。 sheenTint（光泽颜色）：对sheen（光泽度）的颜色控制。 clearcoat（清漆强度）：有特殊用途的第二个镜面波瓣（specular lobe）。 clearcoatGloss（清漆光泽度）：控制透明涂层光泽度，0 =“缎面（satin）”外观，1=“光泽（gloss）”外观。 每个参数的效果的渲染示例如下图所示。\nDisney Principled BSDF 随后的2015年，迪士尼动画工作室在Disney Principled BRDF的基础上进行了修订，提出了Disney Principled BSDF [Extending the Disney BRDF to a BSDF with Integrated Subsurface Scattering, 2015]。\n以下是开源三维动画软件Blender实现的Disney Principled BSDF的图示：\n","date":"2024-12-04T08:29:07+08:00","image":"https://foth0626.github.io/article/brdf-and-rendering-equation/frostbite_pbr_hu_ca1e3d4abd50afed.png","permalink":"https://foth0626.github.io/article/brdf-and-rendering-equation/","title":"The BRDF and Rendering Equation"},{"content":" 本博客为SAST.Graphics组授课文档记录\n``\n前言 本课程大量参考GAMES101、RTR4-CN、B站视频等资料，如有雷同，应该不是巧合。\n我们的授课不包含这些 3D建模软件/游戏引擎入门到精深 计算机视觉（Computer Vision） 深度学习（deep learning）\nml等人工智能领域使用显卡是因为显卡并行处理大型数据和计算矩阵的优势，和图形学没有任何关系！ 我们的课程不需要一张独立显卡/一台游戏本！ 我们的教学聚焦于图形学原理，不需要高性能的显卡做算力支持。只需要你的电脑能够正常启动，那么基本可以肯定你的电脑足以进行编程和学习。\n使用一个IDE（集成开发环境）！ 我不想有人使用\ntxt文本阅读器/记事本 vi/vim/emacs 大哥你至少用个写代码的玩意。。\nDev C++ 不能支持多文件编译的低能软件，界面还丑\n界面过丑不予展示\n个人推荐IDE MSVC：大，全，重；可用，我只推荐windows平台用来做编译器 Visual Studio Code + CMake + MSVC Jetbrains Clion一把梭 关于C++，可以去校科协C++组学习。 学习图形学能对我有什么帮助？ 校招 大部分游戏客户端都会把图形学作为加分项，近年更是在越来越卷的环境下又成为人手必备的技能的趋势。\n考研 计算机图形学是计算机科学大类下的一个子学科。\n计算机图形学简介 计算机图形学是计算机科学的一个子领域，研究数字合成和操作视觉内容的方法。尽管该术语通常指三维计算机图形学的研究，但它也包含二维图形和图像处理。\n图形学细分领域 渲染（Render） 渲染或图像合成是通过计算机程序从2D或3D 模型生成真实感或非真实感图像的过程。可以在包含严格定义的语言或数据结构的对象的_场景文件_中定义多个模型。场景文件包含描述虚拟场景的几何、视点、纹理、照明和着色信息。然后场景文件中包含的数据被传递到渲染程序进行处理并输出到数字图像或光栅图形图像文件。术语“渲染”类似于艺术家对场景的印象的概念。术语“渲染”也用于描述在视频编辑程序中计算效果以产生最终视频输出的过程。\n渲染是3D 计算机图形学的主要子主题之一，在实践中它总是与其他主题相关。这是图形管道中的最后一个主要步骤，为模型和动画提供最终外观。自 20 世纪 70 年代以来，随着计算机图形学的日益复杂，它已成为一门更加独特的学科。\n渲染可用于建筑、视频游戏、模拟器、电影和电视视觉效果以及设计可视化，每种都采用不同的功能和技术平衡。有多种渲染器可供使用。有些集成到更大的建模和动画包中，有些是独立的，有些是免费的开源项目。从内部来看，渲染器是一个基于多个学科精心设计的程序，包括物理光学、视觉感知、数学和软件开发。\n几何（Geometry） 几何学的子领域研究在离散数字环境中三维物体的表示。由于对象的外观在很大程度上取决于其外部，因此边界表示法是最常用的。二维表面是大多数物体的良好表示，尽管它们可能是非流形的。由于曲面不是有限的，因此使用离散数字近似。多边形网格（以及较小程度上的细分曲面）是迄今为止最常见的表示，尽管基于点的表示最近变得更加流行（例如，参见基于点的图形研讨会）。最近，_欧拉_表面描述（即，其中空间样本是固定的），例如水平集，已经发展成用于使经历许多拓扑变化的表面变形的有用表示（流体是最显著的示例）。\n动画仿真（Animation and Simulation） 动画的子领域研究随着时间的推移移动或变形的表面（和其他现象）的描述。从历史上看，这一领域的大多数工作都集中在参数和数据驱动的模型上，但最近随着计算机在计算方面变得更加强大，物理模拟变得更加流行。\n动画子领域包括：\n动作捕捉 角色动画 物理模拟（例如布料建模、流体动力学动画等） 图形学应用领域 (以下图片来自)\n为什么学习图形学？ 图形学学习中的困难 理解真实世界的物理规律并创造真实的虚拟世界 投影，曲线，表面的数学表示 光学和着色的物理学知识 表示/操作3D形体 动画/模拟 Why is GPU? “The display is the computer.” ——Jen-Hsun Huang 计算机八大件 机箱、CPU、主板、内存、散热器、显卡、电源、硬盘\n为什么显卡如此特殊，它和CPU一样，共同拥有作为处理器的崇高地位，却只负责一件事：图像处理？\n可怕的计算量 现代显示器最低分辨率为1920x1080，我们假设每秒渲染60张图像，那么结果是\n1920 * 1080 * 60 = 124,416,000 次！\n如果说你的电脑配置比较好，显示器有4k分辨率（3840x2160），每秒渲染144张图像，那么结果是多少？\n3840 * 2160 * 144 = 1,194,393,600 次！\n不仅如此，我们只考虑了每个像素产生颜色的过程，如果是玩游戏，通常来说会有百万级别的三角面需要同时处理。\n让宝贵的CPU花费大量性能去做这种体力活毫无疑问是非常低性价比和愚蠢的。所以工程师们很快想出了一个方法：我专门做个硬件去产生图像数据不就行了？\nGPU简史 初期（1980s） 在计算机发展初期，计算机图形的显示是由CPU完成的，但是随着计算机图形需求的增长，尤其是游戏，2D图形领域的需求，最开始的图形加速硬件（图形加速器）被设计并制造出来，主要用于三角形的像素扫描线插值，并将其显示在显示器上。这时候的GPU只是一个搬运工，它只负责显示2D图像。此时它被称为图形加速器。\n发展（1990s） 1990年代，3D图形技术随着电子游戏和CAD的发展而发展，市面上出现了大量的3D加速卡，最著名的显卡便是3dfx的Voodoo系列。Voodoo系列卡通过独立的3D处理单元处理几何运算、纹理映射和光栅化，专门加速游戏中的3D图形。这个时期的经典游戏如《古墓丽影》、《雷神之锤》等大幅受益于Voodoo卡的加速。\n图形API逐渐标准化，1992年推出的OpenGL和1995年微软推出了DirectX，给游戏开发者和软件厂商提供了一个统一的平台来开发3D图形应用程序。API的标准化推动了GPU的发展，因为它让硬件厂商能够专注于提高图形处理器的性能，而开发者则可以通过这些标准API与硬件进行交互。\n1999年，划时代的芯片NVIDIA Geforce256 发布了，GPU这个术语被创造出来用以区分GeForce 256 和过去所有图形加速卡的区别。首次引入了硬件变换和光栅化（Transform and Lightling），将图形处理转移到GPU，提高了3D处理的速度。但此时的渲染过程仍然是固定的，开发者无法自由地实现自己的想要的功能。\n可编程着色器（2000s） Vertex Shader 和 Fragment Shader正式出现，开发者可以通过程序自定义想要的效果。\n后续（2000s-至今） 科研人员发现GPU能一口气处理这么多数据，相比CPU更适合做科研时产生的大量数据的处理，CUDA应运而生。一段时间后，人工智能蓬勃发展，GPU的并行处理能力被用来进行人工智能训练。AI的爆火又反过来促进显卡厂商加入Tensor（张量）单元进行ai训练。\nGPU架构 在GPU架构之前，我们先来看看CPU的基础架构。\nCPU 经过优化,可以处理大量的数据结构和大型代码段,CPU 一般都具有多个处理器,每个处理器都以串行的方式来执行代码,但是有限的 SIMD 向量处理是一个小例外。为了最小化延迟所带来的影响,CPU 芯片中的大部分面积都是高速的本地缓存,这些缓存中存满了接下来可能会用到的数据。CPU 还会使用一些智能技术来避免停滞,例如分支预测(branch predication)、指令重排序(instruction reordering)、寄存器重命名(register renaming)和缓存预取(prefetching)等。\nGPU则完全不同，GPU芯片中很大一片面积都是大量的处理器，这些相同的处理器通常有数千个，用来处理相似的数据。为了一次性处理大量的数据，GPU对吞吐量(throughput)做了专门的优化，吞吐量指的是数据能够被处理的最大速度。但是GPU用于控制和缓存的芯片较少，所以GPU的延迟普遍比CPU的延迟要大。\n以AD102为例，GPU芯片有12个GPC，每个GPC内有12个SM单元，每个SM单元有128CUDA核心。\n所以AD102核心中有12 * 12 * 128=18432 个CUDA单元，每个单元负载一个线程。32个CUDA核心组成了一个 warp 。warp作为基本单元接受相同指令和不同的数据进行处理。这种架构叫做SIMD（Single Instruction Multiple Data）\nOther 推荐图书？ 自学路径 GAMES002、GAMES101、tinyrender、GAMES202……\n","date":"2024-11-27T11:01:19+08:00","image":"https://foth0626.github.io/article/introduction-to-graphics-and-gpu/ADA_Arttibutes_hu_fac32162c91c861a.png","permalink":"https://foth0626.github.io/article/introduction-to-graphics-and-gpu/","title":"计算机图形学与GPU架构简介"},{"content":"本文为Graphics组授课留档记录\n“Unweave a ranibow ,as it erewhile made. The tender-person'd Lamia melt into shade.” ——John Keats “如刚才拆解彩虹那般，让光线娇嫩的Lamia黯然失色。” ——约翰 · 济慈 参考资料\nRTR4-CN第八章\nThe Amazing Math behind Colors! 客观与认知——色度学与颜色感知【中科院科学公开课S03E09】\n任何基于物理的渲染方法,其第一步都是以一种精确的方式,来对光进行量化(quantify)。在本小节中,我们首先会介绍辐射度量学(radiometry),因为它与光线的物理传输过程紧密相关。 然后我们紧接着会讨论光度学(photometry),它会根据人眼的灵敏度,对光线值进行加权。\n光 在物理光学(physical optic)中,光被认为是一种电磁横波(electromagnetic transverse wave),它使得电场(electric field)和磁场(magnetic field)在其传播方向的垂直面上来回振荡。电场和磁场的振荡是耦合的,二者的矢量相互垂直,并且长度之比也是固定的.\n光以电磁波的形式存在，光和电子的相互作用十分密切：原子的能级跃迁会吸收/释放 光子。在自然界中，电磁波的波长范围相当广，有波长不到百分之一纳米的伽马波，也有波长长达数万公里的极低频无线电波。可见光是整个电磁波谱的一小部分，是波长为380nm ~ 760 nm的电磁波。牛顿著名的三棱镜分光实验将白光分解为七个颜色（据说是因为牛顿对于音乐的喜爱所以按七个音阶对应成了七个颜色。）\n辐射度量学（Radiometry） 各个辐射量（radiometric quantity）的存在是为了对电磁辐射的各个方面进行测量和度量，例如：总能量、功率（随时间变化的能量）以及相对于面积、方向或者二者的功率密度等。\nRadiant flux（辐射通量） 在辐射度量学中，最基本的单位是辐射通量（radiant flux) $\\phi$ ，辐射通量是指辐射能量随时间的流动变化，又叫做功率（power），其单位为瓦特(watts，W)。\nIrradiance（辐照度） 辐照度（irradiance）是辐射通量相对于面积的密度，即 ( $d\\phi/dA$ )。irradiance 是相对于一个面积来进行定义的，这个面积可能是空间中的一个假想区域，但是在渲染中一般都是物体的表面。irradiance 的单位是瓦特每平方米（$W/m^2$ ）。\nRadiant Intensity（辐射强度） 立体角（Solid Angle） 在二维空间中，我们将角度定义为弧的长度与半径的比值，只需要 $2\\pi$ 就可以表示整个单位圆的角度，在三维空间中，我们使用单位球来定义立体角，即立体角形成的一组方向与单位球所相交的面片的面积。立体弧度为 $4\\pi$ 的立体角可以覆盖整个单位球。 现在我们可以引入辐射强度(radiant intensity) $I$，即辐射通量相对于方向的密度，更准确地说，是相对于立体角的密度( $d\\Phi/d\\omega$ )。它的单位是瓦特每立体弧度（$W/sr$）。\nRadiance(辐射度) 最后，辐射度（radiance） L是对单条光线中电磁辐射的度量。更精确地说，它是辐射通量相对于面积和立体角的密度（ $d^2\\Phi/dAd\\omega$ ）。这里的面积位于垂直于光线的平面上，如果想要在其他方向上对表面施加辐射，则必须使用余弦因子进行校正。我们可能还会遇到一些其他对于 radiance 的定义，它们使用了术语“投影面积”来代表这个校正因子。\nradiance 是传感器（例如眼睛或者相机）所直接测量的对象，因此它对渲染而言至关重要。计算着色方程的目的就是沿着给定的光线，计算从着色点到相机的radiance；沿着这条光线计算出来的结果 L，与第 5 章中的$c_{shaded}$ 在物理上是等价的。radiance的公制单位是瓦特每平方米每立体弧度（ $W/m^2sr$ ）。 环境中的 radiance 可以被认为是五个变量（或者六个变量，将波长考虑在内）的函数，它被称为辐射分布（radiance distribution）；其中有三个变量指定了位置，另外两个变量指定了方向，这个分布函数描述了在空间中任何地方传播的任何光线。根据上面的描述，我们可以这样来理解渲染过程：将眼睛和屏幕定义为一个点和一组方向（例如从眼睛出发，穿过每个像素的光线），然后使用这个函数，在这组方向上对眼睛所在的位置进行评估。\n光度学（Photometry） 辐射度量学仅仅对物理量进行了研究，它完全没有考虑人眼的感知。与此相关的一个领域被称为光度学（photometry），它与辐射度量学类似，不同之处在于，它会根据人眼的敏感度，对辐射度量学中的一切事物进行加权处理。通过乘以 CIE 光度曲线（CIE photometric curve），辐射度量学中的计算结果可以被转换为相应的光度单位。CIE 光度曲线是一条以 555 纳米为中心的钟形曲线，它代表了人眼对各种波长光线的响应程度。\n这个转换曲线与测量单位，是光度学理论和辐射度量学理论之间的唯一区别。每个辐射物理量都有一个对应的光度学物理量，下表给出了它们的名称和单位。这些光度学物理量的单位都有预期的对应关系（例如：lux 的单位是 lumen 每平方米）。虽然逻辑上来讲，lumen（流明）应该是个基本单位，但是在历史上，candela（坎德拉）则被定义为基本单位，而其他单位都是从坎德拉中派生出来的。在北美，照明设计师仍然会使用已被废弃的英制测量单位，而不是使用 lux（勒克斯），这个英制单位叫做英尺烛光（foot-candle，fc）。无论哪种情况，大多数测光仪都会对illuminance 进行测量，这个单位在照明工程（illumination engineering）中十分重要。\nRadiometry Quantity Units Photometric Quantity Units Radiant flux watt (W) Luminous flux lumen (lm) Irradiance W/m^2 Illuminance lux (lx) Radiant intensity W/sr Luminous intensity candela (cd) Radiance W/(m^2·sr) Luminance cd/m^2 (nit) Luminance 通常用来描述平面的亮度。例如：高动态范围（high dynamic range，HDR）电视屏幕的峰值亮度通常在 500 到 1000 尼特（nit）之间。相比之下，晴朗天空的亮度大约为 8000 尼特，60 瓦的电灯泡约为 12 万尼特，地平线上的太阳约为60 万尼特。\n色度学（Colorimetry） 真正关键的特性是波长，眼睛捕捉到波长通过向大脑发送信号，我们将其感知为颜色。因此色彩并非光的固有属性，而是一种心理现象，它与波长有关，本质上是间接的。所以色彩并不仅仅是不同波长的直接对应，因为还有眼镜将光转换成大脑可识别信号。\n眼睛的结构 外界物体经过折射后，成像到视网膜上。\n人类的眼睛血管与神经在感光细胞之前，这是进化史上的遗留问题，为了减弱这种影响，中央的部分血管和神经更薄以减弱影响，就有了中央凹这种结构。盲点则是血管神经穿透眼球连接到大脑，导致该区域没有视觉细胞。 黄斑区聚集了大量的视觉细胞，主要分为两种，分别是视锥细胞（Cones cells）和视杆细胞（Rod cells）。视锥细胞主要负责对颜色的感知，视杆细胞主要负责对亮度的感知。视锥细胞大约数量为600w，每种负责检测对应的波长。 视锥细胞一共有三种，分别对短波长(400 ~ 550nm,响应曲线峰值在440nm），中等波长（400nm ~ 650nm，响应峰值在540nm），长波长（430nm ~ 700nm，响应峰值在570nm）敏感。 把三个视锥细胞的响应曲线绘画出来，大约长这个样子，值得注意的是短波长的绝对响应曲线峰值强度远远低于其他两条响应曲线的峰值强度。因此常会把这些曲线归一化。\n人眼会把短波长，中等波长，长波长的光线识别为蓝色，绿色，红色。这有一些道理，但不准确，长波响应视锥细胞被完全激活时（570nm）时，其实仍然处于绿色范围内。所以根据波长划分才更准确。 色彩空间 由于人类只有三种颜色感受器，所以只用三个数字就可以精确的表示任何颜色。但是如何确定颜色之间的对应关系呢？CIE（Commission Internationale d\u0026rsquo;Eclairag）提出了一套标准，并根据标准进行了配色实验。 当时使用汞灯，汞的原子光谱中的700nm,546nm,436nm可以做的比较纯，然后将三个颜色叠加，再另一侧使用分光计或这光栅等设备得到连续的颜色。通过调节三种颜色的权重获得相同的颜色。就得到了颜色匹配函数（color-matching function)。 有一段曲线的值是负的，这意味我们无法通过混合三色光得到这种颜色，而是需要把对应的光源添加到待测颜色的色块中才能使人眼的感知相同。\n如果把所有波长对应的光显示出来，我们不难发现一些问题：许多颜色有缺失，比如粉色，品红，棕色，米黄？最重要的是：白色和黑色？ 黑色是无光环境下的颜色，除此之外，亮度也是一个需要考虑的问题：眼睛的视锥细胞数量大约有600w，在低亮度的情况下，不可能所有的视锥细胞都能被激活。只有部分视锥细胞被激活的情况下，大脑会把黑色和原色进行混合，形成变体。\n而对于橙色，黄色这种鲜亮的颜色，当变暗后与原来的颜色差别过于明显，我们把它们视为新颜色， 使用亮度和波长，即可表现出一个二维的色彩空间。 现在有一些之前遗漏的颜色可以找到了，但是仍然有很多颜色没有找到：比如品红，粉色。为了解决这个问题，我们需要引入色彩空间的概念，我们把短波长，中波长，长波长作为坐标系的三个轴，然后我们就可以在空间中得到这样一条曲线：\n通过对不同的光线进行混合，就可以在现实中得到这些颜色。\n刚才讲的色彩空间叫做LMS空间，它对于响应曲线是归一化的，如果我们把真正响应曲线进行加权，那么便会得到CIE色彩空间。\n好的，但是这个空间是三维的，如果我想总览所有颜色，就会不太方便。回想之前的内容，降低颜色的亮度会逐渐变成黑色，但是颜色本身的色调是没有改变的，我们把同一色调但是不同亮度的颜色可以在这个空间坐标中连成一条线，这条线被称为色度线，色度线与平面 $x+y+z=1$ 的交点，就可以认为是这个点在平面上的位置。\n","date":"2024-11-24T10:47:33+08:00","image":"https://foth0626.github.io/article/radiometry-and-colorimetry/%E7%94%B5%E7%A3%81%E6%B3%A2%E8%B0%B1_hu_f6a345e83dad6c45.png","permalink":"https://foth0626.github.io/article/radiometry-and-colorimetry/","title":"PBR1：辐射度量学和色度学"},{"content":"当进行model矩阵变换时，如果各个方向的分量变换（特指scale）不是统一的比例，会导致法线出现非预期的结果，如图。 将x变换为原来的 $1/2$ 时，法线会发生一次非预期的变化：法线的变换应该是x轴变化的倒数或者说逆。\n我们需要反转缩放，但是应该让旋转和投影矩阵保持不变，对于顶点的变换，应该有 $$ M = T_1T_2T_3 = S_1R_1P_1...$$ 我们抛弃掉 $Position$ ，位置对于法线的变换没有任何影响，我们现在的矩阵可以简化为 $$M = S_1R_1S_2R_2 ...$$ 我们希望的矩阵长这样 $$O = S^{-1}_1R_1S^{-1}_2R_2$$ 思考一下：对于Model矩阵 $M$ 来说，我们有它的逆 $$M^{-1} = R^{-1}_2 S^{-1}_2 R^{-1}_1 S^{-1}_1$$ 注意到有：\n$$(M^{-1})^T = O$$ 所以将顶点法线转换到坐标空间的正确方法是\n1 2 i.normal = mul(transpose((float3x3)unity_WorldToObject), v.normal); i.normal = normalize(i.normal); 当然，Unity官方提供了一个 UnityObjectToWorldNormal 函数进行这个操作，即有\n1 i.normal = UnityObjectToWorldNormal(v.normal); 查看定义\n1 2 3 4 5 6 7 8 9 10 // Transforms normal from object to world space inline float3 UnityObjectToWorldNormal( in float3 norm ) { #ifdef UNITY_ASSUME_UNIFORM_SCALING return UnityObjectToWorldDir(norm); #else // mul(IT_M, norm) =\u0026gt; mul(norm, I_M) =\u0026gt; {dot(norm, I_M.col0), dot(norm, I_M.col1), dot(norm, I_M.col2)} return normalize(mul(norm, (float3x3)unity_WorldToObject)); #endif } 不难发现转换了乘法的顺序减少了一次转置操作，有利于编译器更好的实现代码。\n","date":"2024-11-14T19:21:57+08:00","image":"https://foth0626.github.io/article/object-normal-to-world-problem/tnmaor6l_hu_f5da8fa0df9233d9.bmp","permalink":"https://foth0626.github.io/article/object-normal-to-world-problem/","title":"Model矩阵对于法线的一些非预期变化"},{"content":"本文为Graphics组授课留档\n\u0026ldquo;All it takes is for the rendered image to look right.\u0026rdquo; ——Jim Blinn\n本节课参考资料：RTR4-CN 第六章\n表面纹理(texture)是指其外观和给人的视觉感受,就像是一幅油画的图案一样。 而在计算机图形学中,纹理化则指的是一个过程,即通过使用一些图像、函数或者其他数据,来对每个表面位置的外观表现进行修改。例如:我们可以将一张砖墙的彩色图像应用于由两个三角形组成的矩形上,而不是去精确表现砖墙的几何结构。当我们观察这个砖墙矩形的时候,对应的彩色图像将会显示在这个矩形所在的位置上,这样可以使得这个矩形看起来很像真实的砖墙。除非相机十分靠近墙壁的话,否则砖墙几何细节的缺乏并不会带来明显的视觉瑕疵。\n纹理管线 纹理化（texturing）是一种用于描述表面材质以及对表面进行修饰加工的有效技术。纹理的工作原理是通过修改着色方程的中的参数，对最终结果产生影响。比如说，对于刚才的那个例子，通过替换点的位置，将顶点颜色为纹理颜色。或者粗糙度纹理修改了表面的粗糙度值，凹凸纹理修改了表面着色法线的方向。\n为了与屏幕上的像素（pixel）有所区别，纹理上的像素通常被称为纹素（texel）。\n纹理化的起点是一个空间中的具体位置，这个位置可以在世界空间中，但是通常是基于模型空间参考系的，因为纹理会随着模型移动而移动。这个空间点会使用一个投影函数（projection function）获得一组数字，它被称为纹理坐标，纹理坐标可以用于访问采样纹理，这个过程称为纹理映射。\n在使用纹理坐标访问纹理之前，还需要使用一个或多个转换函数（corresponder funcion)，来将纹理坐标转换到纹理空间中，用来在纹理中获取像素值。例如：纹理空间位置是图像纹理的数组索引，从而检索到对应的位置的值。检索到的像素值可能还要使用一个值转换函数（value transform function)进行转换，最终这些新值会用于对表面的某些属性进行修改。值得注意的是，并不是每次纹理应用都需要激活管线中的所有步骤。\n例如:对于一个具有砖墙纹理的三角形,我们在其表面上进行采样时会发生如下情况(112如图 6.3 所示):首先我们会在该物体的局部参考系中,找到对应的采样位置(x, y, z),这里假设它是 (−2.3, 7.1, 88.2)。然后会对这个位置坐标应用一个投影函数,就像世界地图是三维地球的二维投影那样,这里的投影函数通常会将一个三维向量 (x, y, z)转换为一个二维向量 (u, v)。本例中所使用的投影函数,实际上与正交投影是等价的(章节 2.3.1),它就像幻灯片放映机一样,将砖墙图像投影到三角形表面上;并且为了最后能将图象值返回到墙面上,其表面上的点都会被转换为一个0-1 范围内的数值对,这里我们假设转换后的值是 (0.32, 0.29),这个数值对也被称为纹理坐标或者 UV 坐标。这个纹理坐标将用于查找纹理贴图在此位置上的颜色值。假设这里我们所使用的砖墙纹理分辨率为 256 × 256,因此使用转换函数,将纹理坐标 (u, v)各自乘以 256,即 (81.92, 74.24)。在丢弃小数部分之后,我们在砖墙图像中进行检索,找到索引值为 (81, 74)的颜色值,这里假设这个颜色值为(0.9, 0.8, 0.7)。同时,我们所使用的纹理颜色位于 sRGB 颜色空间中,因此如果要在着色方程中使用这个颜色值,还需要将其转换到线性空间中,即(0.787、0.604、0.448)。\n投影函数（Projection function） 纹理处理的第一步是获取表面的位置，并将其投影到纹理坐标空间（texture coordinate space）中，这个纹理坐标空间中通常是二维（u,v)的，常见的建模软件允许艺术家定义每个顶点的uv坐标，这些坐标可以从投影函数或者网格展开算法中进行初始化，艺术家也可以编辑uv坐标。\n投影函数的作用通常是将空间中的三维坐标转换为二维纹理坐标，在建模软件中常见的投影包括球面投影，柱面投影，平面投影等。还有一些投影函数根本不是投影操作，而是隐含在表面创建和曲面细分中。例如，参数化生成的曲面定义本身就包含了一组天生的uv坐标。投影函数的最终目标只是生成纹理坐标，将其作为一个与位置有关的函数来进行推导只是一种方法。有时候单个投影函数就可以用于整个模型的投影操作，但是艺术家通常一些工具将模型进行细分，并单独应用不同的投影函数。\n在实时渲染领域，通常在建模时就会使用投影函数，将结果存储在顶点上。但是并不是总是如此，有时在顶点着色器或者像素着色器中应用投影函数会带来一些好处，比如提高精度，有助于实现动画在内的各种效果。有时候一些渲染方法有着独特的投影函数，会进行逐像素的计算，比如环境映射。与投影方向相近的表面会产生严重的扭曲，所以艺术家经常需要手动将模型分解为小块（即建模过程中的展uv）。\n纹理坐标空间并不总是一个二维平面，有时候也可以是一个三维体积，这时纹理坐标有三个分量（u，v，w）。部分情况甚至会用四个坐标（即齐次坐标描述）（s，t，r，q）。\n还有一种重要的纹理坐标空间是方向性的，纹理空间的每个点都通过输入方向来访问。每个点位置上的法线代表了访问该纹理的输入方向。使用这种方向性的纹理最常见的纹理类型就是立方体贴图（cube map）。\n值得注意的是，一维的纹理也有各自的用途。例如：对于一个地形模型而言，颜色可以由高度决定。或者作为一个一维查找表。\n转换函数（Corresponder function） 转换函数用于将纹理坐标转换为纹理空间的具体位置，它们提高了在表面上应用纹理的灵活性。其中一个例子是：使用API选择现有纹理的一部分来显示，并且在后续的操作都只会使用这个子图像。\n另一类转换函数则是矩阵变换，应用于顶点着色器或片元着色器中，他们允许对表面上的纹理进行平移、旋转、缩放、剪切或者投影操作。\n另一类转换控制图像的应用方式。纹理坐标uv只有在（0，1）这个范围才是有意义的的。但是如果纹理坐标位于范围之外时，它应该如何取值呢？转换函数决定了会发生什么。在OpenGL中，这种类型的转换函数被称为包装模式（wrapping mode），在DirectX中被称为纹理寻址模式（texture addressing mode）。\n常见的转换函数包括如下类型：\nwrap（directX），repeat（OpenGL）或者tile：图像表面会不断重复。 mirror：图像会不断重复，但是每重复一次就会被镜像翻转一次。 clamp（directX）或者clamp to edge（opengl）：位于（0，1）范围之外的纹理坐标会被限制在这个范围内。这种模式会导致图像边缘的不断重复，优点在于在纹理附近发生双线性插值时，可以避免从纹理的相反边缘进行采样。 border（directX）或者clamp to border（OpenGL）：位于（0，1）范围之外的纹理坐标会被映射成同一个值。 纹理的重复平铺是一种为场景添加更多视觉细节的廉价方法。但是人眼能识别出这种不自然的重复。一个常见的解决方法与另一个非重复平铺的的纹理结合。另一个方法是，使用着色器实现一些特殊的转换函数，从而将纹理图案和瓦片贴图进行随机重组。\n最后一种被应用的转换函数是隐式的，并且与图像的大小有关。纹理通常会应用在uv坐标的（0，1）范围内。例如砖墙的例子，通过将该范围内的纹理坐标乘以分辨率得到对应的像素位置。这种将纹理坐标限制在（0，1）范围内的优势是不需要对不同分辨率的纹理在顶点内存储不同的纹理坐标值。\n纹理值 生成纹理坐标空间后，便可以用这个坐标获取对应的纹理值。对于图像纹理中，这是通过检索图像中的纹素得到的。实时渲染的绝大多数函数都是图像纹理。但也有程序生成的纹理，这种情况下便不涉及内存查找，而是变成了一个函数值的计算。\n最常见最直接的纹理值便是RGB三元组，它可以用于替换或者修改表面的颜色。另一种类型是RGBA，A（alpha）通道代表了纹理的不透明度。纹理贴图中不仅仅可以存储颜色数据，也可以存储其他类型的数据，比如表面粗糙度等。\n纹理中返回的值可以在使用前进行转换。一个常见的例子是把（0.0,1.0）这个无符号范围映射回（-1.0,1.0）这个范围，用这个方法可以在纹理内存储法线数据。\n图像纹理 像素着色器可以通过纹理坐标传给texture2D等函数，并调用他们来访问纹理，在不同的图形API有两个主要区别。\n在DirectX中，纹理的左上角对应的（0，0），右下角对应（1，1）。而在OpenGL中左下角的位置对应了（0，0）。这正好是DirectX翻转y轴得到的结果。 纹素具有整数类型的坐标，但是我们经常会有访问两个纹素中间的值，并在它们之间进行插值，这就引出了一个问题：像素中心的浮点坐标是什么？但是我们会经常想要访问两个纹素之间的位置,并在它们之间进行插值,这就引出了一个问题：像素中心的浮点坐标是什么？Heckbert讨论了两种可能的模式:截断(truncate)和舍入(round)。DirectX 9 将每个纹素的中心定义在(0.0, 0.0)处,它采用了舍入方法。但是这个系统稍微有点混乱,因为对于 DirectX左上角像素(原点)而言,该像素的左上角坐标为 (−0.5, −0.5) 。DirectX 10 学习了 OpenGL 的纹理坐标系统,让每个纹素的中心值为 (0.5, 0.5),即使用了截断方法,或者更准确地说是向下取整(floor),即小数部分会被丢弃。向下取整是一个更加直观的系统,它可以很好的用语言进行表述,例如:当我们说一个像素位于坐标(5, 9)时,实际上我们指的是沿 u轴方向上从 5.0-6.0 的范围,以及沿 v 轴方向上从 9.0-10.0 的范围。 依赖纹理读取(dependent texture read)是一个值得解释的术语,它包含两个定义。\n第一个定义是对于移动设备而言的，当我们使用texture2D或者类似方式访问纹理并在片元着色器内手动计算纹理坐标，而不是使用顶点着色器传入的、未修改的纹理坐标时，就会发生依赖纹理读取。手动计算纹理甚至包括交换uv这种简单操作！对于老旧的不支持OpengGL ES 3.0的移动设备GPU来说，不发生依赖纹理读取会有更高的效率。因为可以预读取。\n另一个定义则是一个纹理坐标依赖之前的纹理值。比如法线贴图改变了表面法线，而cube map访问又依赖于法线。\n纹理尺寸 通常为 $2^m \\times 2^n$，这样的纹理被称为2次幂（power of two ,POT)纹理，现代GPU可以处理任意大小的非2次幂（non power of two ，NPOT)纹理。但是老旧设备可能不支持NOPT的mipmap。不同的图形API对于纹理尺寸有着不同的上限。 DirectX12 允许一张16384 *16384分辨力的纹理。\n设想一下，纹理被放大和缩小后，这时我们又会看到什么样的图像？这个问题的答案取决于我们使用什么样的采样和过滤方法。\n放大（magnification） 在图 6.8 的最左侧,我们使用了邻近过滤的方法。这种放大技术的一个特点是,单个纹素可能会变得十分明显。这种效果被称为像素化(pixelation);因为该方法在放大的时候,会选取距离每个像素中心最近的纹素,从而产生了块状外观。虽然这种方法的质量有时会很差,但是它的好处在于,只需要为每个像素获取一个纹素即可。\n在图 6.8 的中间,我们使用了双线性插值(有时也会叫做线性插值)方法。对于每个像素而言,这种过滤方法需要找到四个相邻的纹素,并在二维上进行线性插值,从而获得混合后的像素值。虽然双线性插值的结果是比较模糊的,但是它并不会像邻近过滤那样出现锯齿。你可以做一个简单的小实验,尝试眯着眼睛来看左边的图像,你就会发现图像的锯齿也消失了,因为这样做(眯着眼睛观察)的效果其实和低通滤波器是大致相同的,并且更能展示面部的特征。\n在图 6.8 的右侧,我们使用了双三次插值(bicubic filter),它大幅去除了剩余的方块感。需要注意的是,双三次插值比双线性插值的计算成本更高,但是许多的高阶滤波器都可以被表示为重复的线性插值,因此可以通过若干次简单的线性插值,来充分利用纹理单元中用于线性插值操作的 GPU 硬件。\n双线性插值 这里我们回到本章一开始提到的砖块纹理例子:在不舍弃小数的情况下,我们会获得坐标 (pu , pv ) = (81.92, 74.24)。这里我们使用与 OpenGL 同样的纹理坐标系,其原点位于左下角,它与标准的笛卡尔坐标系是相匹配的。我们的目标是在四个最近的纹素中心之间,建立一个局部坐标系,并在这四个纹素中心之间进行插值,最终获得该点的像素值,如图 6.9 所示。为了找到 4 个最近的相邻像素,我们从采样位置减去像素中心的分数部分 (0.5, 0.5),得到 (81.42, 73.74)。在去掉中心的小数部分之后,距离最近的 4 个像素范围即为 (x, y) = (81, 73)到 (x + 1, y + 1) = (82, 74)。在这个例子中,分数部分 (0.42, 0.74)是该采样点在这个局部坐标系(由相邻的四个纹素中心构成)中的位置,我们将这个位置表示为 (u′ , v′ )。\n这里我们将纹理访问函数定义为 t(x, y),该函数会返回对应纹素的颜色,其中 x和y 是整数。那么任意位置 (u′ , v ′ )的双线性插值颜色可以按照以下两步进行计算:首先,使用下方的两个纹素颜色 t(x, y)和 t(x + 1, y),按照参数 u′ 进行插值,即\n$$(1−u')\\ast t(x,y)+u'\\ast t(x+1,y) $$;再使用上方的两个纹素颜色 t(x, y + 1)和t(x + 1, y + 1),按照参数 u′ 进行插值,即\n$$(1−u')\\ast t(x,y+1)+u' \\ast t(x+1,y+1)$$,如图 6.9 左侧的绿色圆圈。然后对这两个值在竖直方向上,按照参数 v′进行插值,即将上述过程结合起来,最终 (pu , pv )处的双线性插值颜色 b为:\n$$b(p_u,p_v) = (1-v')((1−u') t(x,y)+u' t(x+1,y)) + v'((1−u') t(x,y+1)+u' t(x+1,y+1)) $$\n$$= (1-u')(1-v')t(x,y) + u'(1-v')t(x+1,y）+（1-u')v't(x,y+1)+u'v't(x+1,y+1)$$从直观上说，距离采样位置越近的纹素，对于颜色的影响就越大，注意到：右上角纹素的影响力和左下角的矩形面积相同。\n双三次插值 在刚才那张图的右侧，我们使用了双三次插值（bicubic filter)，需要注意的是，双三次插值比双线性插值的计算成本更高。还有一种更简单的技术，使用一个简单的平滑曲线进行插值。最常见的是smoothstop和quintic曲线\nSmoothstep： $x^2(3-2x)$ Quintic： $x^3(6x^2-15x+10)$ 其中，smoothstep函数具有 $s\u0026rsquo;(0) = s\u0026rsquo;(1)=0$ 的性质（ $C^1$ 连续），quintic曲线具有类似的性质，唯一不同的是 $q\u0026rsquo;\u0026rsquo;(0)=q\u0026rsquo;\u0026rsquo;(1)=0$ ( $C^2$连续）。\n缩小（minificatioin） 当纹理被压缩时,平面上的一个像素单元格可能会占据好几个纹素。为了正确获得这个像素的颜色值,我们应当将这几个纹素对像素的影响整合起来。然而,精确确定某个像素附近所有纹素对其的影响是很难的,而且想要以实时的速度来完美地实现这一点几乎是不可能的。\n最简单的方法是使用邻近过滤（nearest neighbor）这个方法会产生严重的锯齿问题.\n当表面相对于相机发生移动时，这种瑕疵会变得更加明显，这种在运动中所产生的瑕疵被称为时域锯齿（temporal aliasing）。另一个常用的手法是双线性插值，但是当一个像素受到超过四个像素的影响时，双线性插值就会失效并开始产生锯齿。\n走样根据之前的讨论，走样问题可以通过采样技术和滤波技术来解决。为了实现这个目标，我们要么提高像素的采样频率要么降低纹理的信号频率。但是采样频率的提高总是有限的，我们需要一些技术来降低纹理的频率。\nMipmap mipmap是最流行的纹理抗锯齿方法，现如今所有的图形加速器都支持这种方法。 mip是拉丁语multum in parvo 的缩写，意思是一个很小的地方有很多东西。这揭示了mipmap的工作原理：将原始图像反复过滤为更小的图像。 在使用 mipmap 滤波器的时候,在实际渲染发生之前,原始纹理图像会生成一系列较小尺寸的版本。原始纹理(第 0 级)会被下采样到原始尺寸的四分之一,每个新生成的纹素值,通常为原始纹理中四个相邻纹素的平均值,这个新生成的纹理(第 1 级)有时也会被叫做原始纹理的子纹理(subtexture)。这个下采样的过程会被递归执行,直到最终生成的某个纹理的维度为 1。这组图片的集合通常被称为一个 mipmap 链(mipmap chain)。 生成高质量 mipmap 的两个重要因素分别是:使用良好的过滤和伽马校正。生成mipmap 的常用方法是将每 2 × 2的纹素进行平均,从而获得下一级 mip 所对应的纹素值。具体使用的是一个 box 滤波器,虽然这可能是最糟糕的一个滤波器,使用box 滤波器可能会导致较差的质量,因为它会对低频信息进行模糊,同时保留一些会产生锯齿的高频信息。最好是使用高斯、Lanczos、Kaiser 或者类似的滤波器,这些滤波器的源代码基本都有免费高效的开源实现,同时有一些 API 还支持在 GPU 上进行过滤操作。\n在靠近纹理边缘进行过滤的时候的地方,需要注意纹理的包装模式(wrapping mode)。\n对于在非线性颜色空间中进行编码的纹理(例如大多数的彩色纹理),在过滤时忽略伽玛校正会修改该层级 mipmap 的感知亮度。如果使用了未校正的mipmap,相机距离物体越远,物体整体看起来就会越暗,对比度和表面细节也会受到影响。由于这个原因,因此将这种纹理(例如颜色纹理)从 sRGB 颜色空间转换到线性颜色空间是十分重要的,我们会在线性空间中完成 mipmap 的生成和过滤,然后将生产的结果转换回 sRGB 颜色空间中并进行存储。大多数图形 API 都支持 sRGB 纹理,因此可以在线性空间中正确生成 mipmap,并将结果存储在 sRGB中。当访问 sRGB 纹理的时候,它们首先会被转换到线性空间中,以便正确地执行放大(magnification)和缩小(minification)操作。\nmipmap 的好处在于,它并不是去单独计算每个纹素对像素的影响,而是对预先生成的纹素集合进行访问和插值,无论纹理压缩的程度如何,这个过程的时间开销是固定的。然而,mipmap 也存在几个缺陷,其中一个主要的问题就是过度模糊(overblurring)。我们假设现在有一个像素单元格,它在 u方向上覆盖了大量的纹素,而在 v方向上只覆盖了少量的纹素,这种情况通常发生在相机以一个掠射角度来观察纹理表面的时候。在这种情况下,需要沿着纹理的其中一个轴进行缩小,沿着另一个轴进行放大,这会导致像素在纹理上的投影区域是一个长宽比很大的矩形;而我们在访问 mipmap 时,只能检索纹理上的正方形投影区域,无法检索矩形投影区域。为了避免走样,我们会选择较长的那个边所形成的正方形,来作为对像素单元格覆盖率的近似度量,这导致检索到的样本往往会相对模糊。这种现象可以在图中看到,图片右侧向远处延伸的线条会变得过度模糊。 Summed-Area 表(SAT) 另一种能够避免过度模糊的方法是面积积分表(summed-area table,SAT,也可以叫做求和面积表),后文中我们会简称为 SAT。想要使用这种方法,首先要创建一个尺寸与纹理相同的数组,但是颜色存储的精度要更高(例如:每个红绿蓝颜色分量都会占据 16 个 bit)。在数组中的每个位置上,该位置上的纹素会和 (0, 0)处的纹素(原点)构成一个矩形,计算并存储区域中所有纹素值的总和。在纹理化的过程中,屏幕上像素在纹理上的投影区域是一个矩形;然后会通过 SAT 来确定这个矩形区域的平均颜色,并将其作为该像素的纹理颜色。这个计算过程如图 6.17 所示,具体的平均颜色计算公式如下:\n$$c = \\frac{s[x_{ur},y_{ur}]-s[x_{ur},y_{ll}]-s[x_{ll},y_{ur}]+s[x_{ll},y_{ll}]}{(x_{ur}-x_{ll})(y_{ur}-y_{ll})}$$\n图像右侧向远处地平线延申的线条变得更加清晰了,但是中间对角相交的线条仍然是很模糊的。这个问题的原因在于,当我们沿着对角线观察纹理的时候,像素投影所生成的区域是一个沿对角线的细长矩形,该矩形对应的包围盒中包含了大量无关的纹素,例如:在图中,想象此时像素的投影区域是一个横跨纹理对角线的细长区域,它所对应的包围盒几乎会占据整个纹理,而真正位于像素投影区域内的纹素数量则很少。此时这种方法会对整个纹理矩形进行平均,这个结果包含了大量的无关纹素值,从而导致模糊的产生。\nSAT 是各向异性过滤(anisotropic filtering)算法的其中一个例子,这类算法用于检索非正方形投影区域的纹理值,SAT 对于接近水平方向或者竖直方向的投影区域最为有效。还需要注意的是,对于 16 × 16或者尺寸更小的纹理,SAT 需要至少两倍的内存;而对于尺寸更大的纹理,则需要更高的存储精度,因为像素值的和会很大,精度过低可能会导致数值溢出。\nSAT 可以提供更好的质量,并且额外的内存开销还算合理,因此它在现代的 GPU 上也被广泛应用。高质量的过滤方法对于高级渲染技术的质量而言至关重要。例如,Hensley 等人提出了一个高效的实现,并展示了使用 SAT 采样来改善glossy 反射的方法。其他使用区域采样的算法也可以通过 SAT 方法进行改进,例如如景深,阴影贴图,和模糊反射等。\n无约束的各向异性过滤 在之前我们所提到的方法中,会在 mipmap 中的一个正方形区域内进行采样,这可能会导致采样到很多无关纹素,使得表面变得模糊。这里我们将要介绍的算法,并不是使用单个 mipmap 采样区域来对该投影形成四边形进行近似,而是会使用多个正方形来进行近似。我们使用四边形中较短的那个边来确定 d的值(而在原始的 mipmap中,通常会使用较长的边来确定 d),这样做会使得每个 mipmap 样本的平均面积更小(包含了更少的无关像素,因此会减少模糊的出现)。而四边形的长边则被用来创建一条与其平行,并且穿过四边形中点的各向异性线(line of anisotropy)。当各向异性的比例在 1 : 1和 2 : 1之间时,我们会沿着这条线取两个样本(如图 6.18 所示);各向异性的比例越高,沿轴采集的样本就越多。\n体积纹理（volume texture） 对图像纹理直接进行扩展可以得到三维图像数据,它通过坐标 (u, v, w)或者 (s, t, r)来进行访问,例如:医学成像数据可以生成三维网格,通过在网格中移动成像平面,可以看到这些数据的二维切片。\n如今大部分 GPU 都支持体积纹理(volume texture)的 mipmap,由于在体积纹理的单个 mipmap 级别内,需要使用三线性插值来进行过滤,因此在不同 mipmap 级别之间,需要四线性插值(quadrilinear interpolation)来进行过滤。由于需要对 16个纹素的结果进行求平均,因此可能会导致一些精度不足的问题,这可以通过使用更高精度的体积纹理来进行解决。\n虽然体积纹理对于存储空间的要求比较高,并且过滤的计算成本也比较高,但它确实具有一些特殊的优势。由于可以直接使用纹理坐标来表示三维的空间位置,因此可以跳过为三维网格寻找一个良好二维参数化表示的复杂过程(UV 拆分)。这避免了二维参数化时经常出现的扭曲和接缝问题。体积纹理也可以用来表示木材或者大理石等材质的体积结构,具有这种纹理的模型,看起来就像是使用这种材料雕刻出来的一样。\n使用体积纹理来对表面进行纹理化操作是非常低效的,因为体积纹理中的绝大部分样本都没有被使用。Benson 和 Davis 以及 DeBry 等人，讨论了将纹理数据存储在稀疏八叉树中的方法,这种方法非常适合交互式的三维绘画系统,因为我们在创建表面的时候,不需要显式地指定它的纹理坐标,同时八叉树结构可以将纹理细节保留到任何我们想要的级别。Lefebvre 等人讨论了在现代 GPU 上实现八叉树纹理的细节;Lefebvre 和 Hoppe提出了一种将稀疏体积数据打包成较小纹理的方法。\n立方体贴图（cube map） 另一种类型的纹理叫做立方体纹理(cube texture)或者立方体贴图(cube map),它具有六个正方形的纹理,立方体的六个面分别对应了这个六个正方形纹理。访问立方体贴图需要使用一个包含三个分量的纹理坐标向量,这个向量代表了从立方体中心向外发射的射线方向。这个射线与立方体交点的计算过程如下:向量中绝对值最大的那个分量,决定了射线会射向哪个立方体表面(例如:向量(−3.2, 5.1, −8.4)代表了射线会射向 −z面)。将剩余的两个坐标分量分别除以最大分量的绝对值(即 8.4),此时这两个分量的大小位于 [−1, 1]内,然后再将其重新映射到 [0, 1]中以计算纹理坐标,例如:坐标 (−3.2, 5.1)会被映射为((−3.2/8.4 + 1)/2,(5.1/8.4 + 1)/2) ≈ (0.31, 0.80)。立方体贴图对于表示方向函数的值而言非常有用;它们最常用于环境映射中。\n程序化纹理 Adobe Substance 3D Designer 个人的入门教程，程序化生成丝绸材质。\n程序化背后的本质是算法和编程思维，以及对现实世界的拆分和再理解。\n纹理动画 纹理坐标也不一定是静态的。无论是在网格数据本身对纹理坐标进行修改,还是通过顶点着色器或者像素着色器中的函数,来对纹理坐标进行修改,应用程序设计人员都可以显式地改变帧与帧之间的纹理坐标。想象一下,现在我们有了一个已经建模好的瀑布模型,并且它已经被一个图像纹理化了,使得它看起来很像瀑布。假设纹理坐标v是水流的方向,为了让水流动起来,必须从每一帧的坐标 v 中减去一定的数值。纹理坐标的减法操作会使得纹理本身看起来正在向前移动。\n可以通过对纹理坐标应用变换矩阵来生成更加精细的效果。除了平移之外,它还允许其他的线性变换操作,例如缩放、旋转和剪切,图像扭曲(image warping)和变形转换(morphing transforms),以及广义投影等。通过在 CPU 或者着色器中应用变换函数,可以生成更复杂的效果。\n通过使用纹理混合(texture blending)技术,还可以实现其他的动画效果。例如:从一个大理石纹理出发,将其渐变为一个肉质纹理,从而使得雕像看起来像是活过来一样。\n纹理映射 纹理的一个常见用途是对材质属性进行修改,从而影响着色方程的计算结果。现实世界中的物体通常都会具有不同的表面材质属性,为了模拟这样的物体,像素着色器可以从纹理中读取纹理值,并在计算着色方程之前,使用它们来修改材质的参数。纹理最常修改的参数就是表面是颜色,这种纹理通常被称为反照率颜色贴图(albedo color map)或者漫反射颜色贴图(diffuse color map)。但是,理论上任何参数都可以被纹理进行修改,例如:替换、相乘或者以其他方式等。例如在图 6.25 中的表面,应用了三种不同的纹理来替换常量值。\n","date":"2024-11-12T20:51:56+08:00","image":"https://foth0626.github.io/article/rtr4-chapter06-texture/%E7%BA%B9%E7%90%86%E7%AE%A1%E7%BA%BF_hu_105ccf9f5fa80060.png","permalink":"https://foth0626.github.io/article/rtr4-chapter06-texture/","title":"RTR4-CN 第六章 纹理（Texture）"},{"content":"托更了很久终于更新了，主要是写到第三课的时候忍不住开始想怎么重构这节课写的画三角面的函数，然后思考函数怎么解耦，并且对于传入的三角面类型应该是浮点数还是整形的纠结了很久，无论是哪种都有足够的理由，浮点型精确，整型符合最后的像素的写入。最后选择了先写完再说，写出一坨屎山再说。 这节课主要写了如何把上次写的线框画成三角面。\n三角形的基础构想 不难想到，三角形可以用一行一行地填充满，但是如果从下到上的填充，那么就不可避免的会被分为两部分，由中间的点分为上下两部分，于是就有基础的三角绘图函数 triangle\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void triangle(const std::array\u0026lt;Vec3i, 3\u0026gt; \u0026amp;verts, const TGAImage \u0026amp;image, const TGAColor \u0026amp;color) { auto point0 = verts.at(0); auto point1 = verts.at(1); auto point2 = verts.at(2); //avoid a triangle degenerating into a line if (std::abs(point0.y-point1.y)\u0026lt;=.1 \u0026amp;\u0026amp; std::abs(point0.y - point2.y)\u0026lt;= .1) return; //sort three point3 , now they sort by y in ascending order, we call them A , B , C if (point0.y \u0026gt; point1.y) std::swap(point0, point1); if (point1.y \u0026gt; point2.y) std::swap(point1, point2); if (point0.y \u0026gt; point1.y) std::swap(point0, point1); //calc the slope and draw triangle for (int y = point0.y; y \u0026lt;= point2.y; ++y) { auto pointA = point0 + (point2 - point0) * static_cast\u0026lt;float\u0026gt;(y - point0.y) / (point2.y - point0.y); auto pointB = y \u0026gt;= point1.y ? point1 + (point2 - point1) * static_cast\u0026lt;float\u0026gt;(y - point1.y) / (point2.y - point1.y) : point0 + (point1 - point0) * static_cast\u0026lt;float\u0026gt;(y - point0.y) / (point1.y - point0.y); if (pointA.x \u0026gt; pointB.x) std::swap(pointA, pointB); for (int x = pointA.x; x \u0026lt;= pointB.x; ++x) { image.set(x, y, color); } } } 加速结构 包围盒 然后我们使用包围盒加速，通过把遍历范围从整个屏幕缩小到包围着三角形的最小四边形，我们可以加速绘图。我已经把寻找包围盒抽象成为了一个单独的函数 boundingBox 。当然，未来可能会修改这个函数的参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct BoundingBox { int minX; int minY; int maxX; int maxY; }; BoundingBox boundingBox(const std::array\u0026lt;Vec2i,3\u0026gt;\u0026amp; triangle,const TGAImage\u0026amp; image) { Vec2i boundingBoxMin{image.get_width() - 1, image.get_height() - 1}; Vec2i boundingBoxMax{0, 0}; Vec2i clamp(image.get_width() - 1, image.get_height() - 1); for (int i = 0; i \u0026lt; 3; i++) { boundingBoxMin.x = std::max(0, std::min(boundingBoxMin.x, triangle[i].x)); boundingBoxMin.y = std::max(0, std::min(boundingBoxMin.y, triangle[i].y)); boundingBoxMax.x = std::min(clamp.x, std::max(boundingBoxMax.x, triangle[i].x)); boundingBoxMax.y = std::min(clamp.y, std::max(boundingBoxMax.y, triangle[i].y)); } return {boundingBoxMin.x, boundingBoxMin.y, boundingBoxMax.x, boundingBoxMax.y}; }; 重心坐标 然后我们需要思考如何判断一个点在三角形内还是在三角形外，一般来说，有两种方法：第一种方法是使用向量相乘的方法，通过判断点与三个顶点形成的向量和边的叉积是否同号判断。还有一种方法是使用重心坐标法，判断是否符合重心坐标的结果。这里使用重心坐标法，向量相乘可以参考GAMES101作业的实现。\n1 2 3 4 5 6 Vec3f barycentric(const std::array\u0026lt;Vec2f, 3\u0026gt; \u0026amp;pts, const Vec2i \u0026amp;P) { Vec3f u = cross(Vec3f{pts[2].x - pts[0].x, pts[1].x - pts[0].x, pts[0].x - P.x}, Vec3f{pts[2].y - pts[0].y, pts[1].y - pts[0].y, pts[0].y - P.y}); if (std::abs(u.z) \u0026lt; 1) return Vec3f{-1, 1, 1}; return Vec3f{1.f - (u.x + u.y) / u.z, u.y / u.z, u.x / u.z}; } 这是最终的 triangle_bbox 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void triangle_bbox(const std::array\u0026lt;Vec3i,3\u0026gt;\u0026amp; triangle,const TGAImage \u0026amp;image, const TGAColor \u0026amp;color) { BoundingBox bbox = boundingBox({{Vec2i{triangle[0].x, triangle[0].y}, Vec2i{triangle[1].x, triangle[1].y}, Vec2i{triangle[2].x, triangle[2].y}}}, image); for (int x = bbox.minX; x \u0026lt;= bbox.maxX; x++) { for (int y = bbox.minY; y \u0026lt;= bbox.maxY; y++) { Vec2i P{x, y}; Vec3f bc_screen = barycentric({{Vec2f{triangle[0].x, triangle[0].y}, Vec2f{triangle[1].x, triangle[1].y}, Vec2f{triangle[2].x, triangle[2].y}}}, P); if (bc_screen.x \u0026lt; 0 || bc_screen.y \u0026lt; 0 || bc_screen.z \u0026lt; 0) continue; image.set(x, y, color); } } } 我们认为光强是表面法线和光线方向的乘积（兰伯特模型） 最终代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int main() { const Model model(\u0026#34;../../obj/african_head.obj\u0026#34;); const auto modelFace = model.getFaces(); const auto modelVerts = model.getVerts(); TGAImage gamma_head(800, 800, TGAImage::RGB); Vec3f light_dir{0,0,-1.}; for (int i=0; i\u0026lt;model.getFaces().size(); ++i) { auto face = modelFace[i]; const std::array face_triangle = {Vec3i{(int)((modelVerts[face[0][0]-1].x+1.)*gamma_head.get_width()/2.), (int)((modelVerts[face[0][0]-1].y+1.)*gamma_head.get_height()/2.), (int)((modelVerts[face[0][0]-1].z+1.)*gamma_head.get_height()/2.)}, Vec3i{(int)((modelVerts[face[1][0]-1].x+1.)*gamma_head.get_width()/2.), (int)((modelVerts[face[1][0]-1].y+1.)*gamma_head.get_height()/2.), (int)((modelVerts[face[1][0]-1].z+1.)*gamma_head.get_height()/2.)}, Vec3{(int)((modelVerts[face[2][0]-1].x+1.)*gamma_head.get_width()/2.), (int)((modelVerts[face[2][0]-1].y+1.)*gamma_head.get_height()/2.), (int)((modelVerts[face[2][0]-1].z+1.)*gamma_head.get_height()/2.)}}; Vec3f world_coords[3]; for (int j=0; j\u0026lt;3; ++j) { world_coords[j] = modelVerts[face[j][0]-1]; } Vec3f n = cross((world_coords[2]-world_coords[0]),(world_coords[1]-world_coords[0])); n.normalize(); float intensity = dot(n,light_dir); if (intensity\u0026gt;0) { triangle_bbox(face_triangle, gamma_head, TGAColor(intensity*255, intensity*255, intensity*255, 255)); } } gamma_head.flip_vertically(); gamma_head.write_tga_file(\u0026#34;lesson2_gamma_head.tga\u0026#34;); return 0; } 结果 如图所示 ZBuffer 现在我们来创建一个ZBuffer来消除这个不正确的嘴巴\n","date":"2024-10-11T14:29:28+08:00","image":"https://foth0626.github.io/article/tiny-renderer-02/cover_hu_8bec191cdde93e54.png","permalink":"https://foth0626.github.io/article/tiny-renderer-02/","title":"myLittleRenderer02 - 三角面"},{"content":"前言 本人打算提高个人的C++基础编程水平和图形学理解，所以再再再次启动了tinyrenderer的程序编写，相较于之前被动的抄写代码，我准备选择直接观察他的代码结果后根据自己的理解进行编写，并进行结果比较。 开始编写前，思考出如图所示的基础架构（如果这可以称为架构的话） 项目结构如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . ├── CMakeLists.txt ├── geometry.cpp ├── geometry.h ├── main.cpp ├── model.cpp ├── model.h ├── obj │ └── african_head.obj ├── rasterizer.cpp ├── rasterizer.h ├── README.md ├── sandbox.cpp ├── tgaimage.cpp └── tgaimage.h 源码可以在这里看到 tgaimage.h和tgaimage.cpp复制自ssloy的初始提交，可以在lesson01的wiki看到，在此不多赘述。\n基础设施建设 向量类 在GAMES101的作业中，使用了线性代数库 Eigen，但是对于本环境的代码来说，并不需要这么强大的功能，所以参考原仓库手搓了一份向量类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 template \u0026lt;typename T\u0026gt; struct Vec2{ union{ struct{T x, y;}; struct{T u, v;}; }; Vec2(): x(0), y(0) {} Vec2(T _x, T _y): x(_x), y(_y) {} }; template \u0026lt;typename T\u0026gt; struct Matrix4{ std::array\u0026lt;T,16\u0026gt; data; Matrix4():data({0}){} T get_index(int i, int j) const{ return data[i * 4 + j]; } Matrix4(std::initializer_list\u0026lt;T\u0026gt; list) requires requires{list.size() == 16;}{ int i = 0; for(auto it = list.begin(); it != list.end(); it++){ data[i++] = *it; } } }; 仅做举例，关于重载运算符等操作不多赘述。\n其中，使用 union 内的 匿名 struct 达到了.x 与.u 访问同一内存的效果。 Matrix4(std::initializer_list\u0026lt;T\u0026gt; list) requires requires{list.size() == 16; 的写法来自软研C++组的支持， requires requires{list.size() == 16} 表明在构造函数时必须调用一个16个元素的列表。\nMatrix 结构体尚未经过测试，可能存在bug。\nModel类 头文件定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Model{ public: Model() = delete; explicit Model(const std::string\u0026amp; filename); [[nodiscard]] std::vector\u0026lt;Vec3f\u0026gt; getVerts() const {return verts_;} [[nodiscard]] std::vector\u0026lt;Vec2f\u0026gt; getUV() const {return uv_;} [[nodiscard]] std::vector\u0026lt;Vec3f\u0026gt; getNorms() const {return norms_;} [[nodiscard]] std::vector\u0026lt;std::array\u0026lt;std::array\u0026lt;unsigned short,3\u0026gt; , 3\u0026gt;\u0026gt; getFaces() const {return faces_;} private: std::vector\u0026lt;Vec3f\u0026gt; verts_; std::vector\u0026lt;Vec2f\u0026gt; uv_; std::vector\u0026lt;Vec3f\u0026gt; norms_; std::vector\u0026lt;std::array\u0026lt;std::array\u0026lt;unsigned short,3\u0026gt;, 3\u0026gt;\u0026gt; faces_; }; wavefront obj 文件是由wavefront 公司所创建的模型格式，受到各类建模软件的广泛支持。该模型会在行首声明数据类型\nv代表vertice，顶点 vt 代表vertice texcoord，纹理坐标 vn代表nromal，法线 f代表face，即面\nface应该是最特殊的行数，下面是一个示例 1 2 3 f 321/304/321 318/302/318 147/127/147 f 456/446/456 321/304/321 525/517/525 f 456/446/456 525/517/525 457/447/457 数据每一行分成了三部分，每一部分都代表了一个顶点数据，分别代表顶点索引，贴图索引和法线索引，即\n1 vert/texture/normal vert/texture/normal vert/texture/normal 所以使用了 std::vector\u0026lt;std::array\u0026lt;std::array\u0026lt;unsigned short, 3\u0026gt;, 3\u0026gt;\u0026gt; 这种臃肿的数据结构。\n构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 Model::Model(const std::string \u0026amp;filename) { std::ifstream file(filename); if ( !file.is_open()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error opening file \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; std::endl; return; } std::string line; while (std::getline(file, line)){ std::istringstream iss(line); std::string type; iss \u0026gt;\u0026gt; type; if(type == \u0026#34;v\u0026#34;) { Vec3f v; iss \u0026gt;\u0026gt; v.x \u0026gt;\u0026gt; v.y \u0026gt;\u0026gt; v.z; verts_.push_back(v); }else if(type == \u0026#34;vt\u0026#34;){ Vec2f vt; iss \u0026gt;\u0026gt; vt.x \u0026gt;\u0026gt; vt.y; uv_.push_back(vt); } else if (type == \u0026#34;vn\u0026#34;){ Vec3f vn; iss \u0026gt;\u0026gt; vn.x \u0026gt;\u0026gt; vn.y \u0026gt;\u0026gt; vn.z; norms_.push_back(vn); } else if (type == \u0026#34;f\u0026#34;){ std::array\u0026lt;std::array\u0026lt;unsigned short, 3\u0026gt;, 3\u0026gt; face{}; char slash; for (int i = 0; i \u0026lt; 3; i++) { iss \u0026gt;\u0026gt; face[i][0] \u0026gt;\u0026gt; slash \u0026gt;\u0026gt; face[i][1] \u0026gt;\u0026gt; slash \u0026gt;\u0026gt; face[i][2]; } faces_.push_back(face); } } file.close(); std::cout \u0026lt;\u0026lt; \u0026#34;Loaded\u0026#34; \u0026lt;\u0026lt; verts_.size() \u0026lt;\u0026lt; \u0026#34; vertices\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Loaded\u0026#34; \u0026lt;\u0026lt; uv_.size() \u0026lt;\u0026lt; \u0026#34; uv\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Loaded\u0026#34; \u0026lt;\u0026lt; norms_.size() \u0026lt;\u0026lt; \u0026#34; normals\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Loaded\u0026#34; \u0026lt;\u0026lt; faces_.size() \u0026lt;\u0026lt; \u0026#34; faces\u0026#34; \u0026lt;\u0026lt; std::endl; } 构造函数会打开文件后按行读取，根据行首的类型压入对应的动态数组，并在读取完后输出消息读取数量。（不知道为什么，switch语句不支持string类型，所以使用连续的 ifelse 进行逻辑判断。）\n布雷森汉姆直线算法 布雷森汉姆的核心思想是通过整形的计算代替浮点数的计算，获得更好的性能。\n对于斜率大于1或斜率为负数这类情况，布雷森汉姆算法会交换起始点，由x步进改为y步进等方法保证适用于各种情况。算法实现来自GAMES101的作业实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 void line(const Vec2i p1, const Vec2i p2, TGAImage \u0026amp;image, const TGAColor\u0026amp; color) { int x1 = p1.x; int y1 = p1.y; int x2 = p2.x; int y2 = p2.y; int x, y, xe, ye ; int dx = x2 - x1; int dy = y2 - y1; int dx1 = std::abs(dx); int dy1 = std::abs(dy); int px = 2 * dy1 - dx1; int py = 2 * dx1 - dy1; if (dy1 \u0026lt;= dx1) { if (dx \u0026gt;= 0) { x = x1; y = y1; xe =x2; }else { x =x2; y = y2; xe = x1; } image.set(x, y, color); for (int i = 0; x \u0026lt; xe; i++) { x = x + 1; if (px \u0026lt; 0) { px = px + 2 * dy1; }else { if ((dx \u0026lt; 0 \u0026amp;\u0026amp; dy \u0026lt; 0) || (dx \u0026gt; 0 \u0026amp;\u0026amp; dy \u0026gt; 0)) { y = y + 1; }else { y = y - 1; } px = px + 2 * (dy1 - dx1); } image.set(x, y, color); } }else { if (dy \u0026gt;= 0) { x = x1; y = y1; ye = y2; }else { x = x2; y = y2; ye = y1; } image.set(x, y, color); for (int i = 0; y \u0026lt; ye; i++) { y = y + 1; if (py \u0026lt;= 0) { py = py + 2 * dx1; }else { if ((dx \u0026lt; 0 \u0026amp;\u0026amp; dy \u0026lt; 0) || (dx \u0026gt; 0 \u0026amp;\u0026amp; dy \u0026gt; 0)) { x = x + 1; }else { x = x - 1; } py = py + 2 * (dx1 - dy1); } image.set(x, y, color); } } } 绘图 此时我们已经准备好了所有基本设备，准备好测试文件 sandbox.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026#34;rasterizer.h\u0026#34; #include \u0026#34;tgaimage.h\u0026#34; #include \u0026#34;common.h\u0026#34; #include \u0026#34;model.h\u0026#34; int main() { TGAImage image(800, 800, TGAImage::RGB); const Model model(\u0026#34;../../obj/african_head.obj\u0026#34;); const auto modelFace = model.getFaces(); const auto modelVerts = model.getVerts(); for (int i=0; i\u0026lt;model.getFaces().size(); ++i) { auto face = modelFace[i]; for (int j=0; j\u0026lt;3; ++j) { Vec3f v0 = modelVerts[face[j][0]-1]; Vec3f v1 = modelVerts[face[(j+1)%3][0]-1]; line({(int)((v0.x+1.)*image.get_width()/2.), (int)((v0.y+1.)*image.get_height()/2.)}, {(int)((v1.x+1.)*image.get_width()/2.), (int)((v1.y+1.)*image.get_height()/2.)}, image, white); } } image.flip_vertically(); image.write_tga_file(\u0026#34;lesson1.tga\u0026#34;); return 0; } 画出封面图\n","date":"2024-09-28T15:20:01Z","image":"https://foth0626.github.io/article/tiny-renderer-01/head_hu_7c087f1da8c51736.png","permalink":"https://foth0626.github.io/article/tiny-renderer-01/","title":"myLittleRender01-直线与线框"},{"content":"封面来自KiTA的墨染の桜\n本篇博客更新于2024.11.18\n为什么选择更换博客 本人上一个博客大约在2023年3到4月左右部署，使用的是Typecho框架下的Joe主题，域名在Namesilo购买，服务器算是白嫖的同学的（甚至证书和cdn之类的也是他帮忙搞的），他的个人博客贴在这里：Glucy2的个人博客。总而言之，感激不尽。 这个博客平稳运营了两年，但是由于本人的摆烂行径，在两年内除了一篇初始博客之外并没有写其他文章，几乎接近荒废。最近重拾学习，准备重新开始写博客。\n两年前选择框架时，选择了动态博客是因为支持评论系统，但是由于不好意思继续白嫖服务器，顺便薅薅github羊毛，准备更换到GithubPages做静态博客。\n然后本人发现了静态博客也可以通过第三方的托管与插件实现评论系统，最后的阻碍也可以被解决，便最终决定重新开始。\n框架选择 静态博客框架在简单查询后，Jekyll，Hexo，Hugo 最终加入决赛圈。Jekyll是github 官方推荐的框架，Hexo和Hugo都是被很多人使用的博客框架。\n首先是Hexo和Hugo的比较，最终结论是两者功能都比较相似，但是Hugo在生成时较Hexo更加快速，所以Hexo被我放弃了。 然后是Jekyll 和 Hugo，经过既不仔细也不严谨的搜索后，选择了Hugo，理由是部署流程较为简单不需要过多操心。\n主题选择 主题使用Stack，来源于Hugo的官方主题列表，网站按Github的star数排序，简单浏览前几个主题后选择比较对眼的stack。 从stack的快速开始仓库fork到我的账户并命名为usrname.github.io 后clone到本地，就完成了基本部署。 在settings-\u0026gt;pages设置中选择gh-pages 分支就可以浏览主题模板了。\n快速开始仓库中声明了需要原仓库https://github.com/CaiJimmy/hugo-theme-stack，这导致了之后的一些问题，我会在稍后说明\n一些小主题更改 基本设置 在config.toml 中，更改如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Change baseurl before deploy baseurl = \u0026#34;https://foth0626.github.io\u0026#34; languageCode = \u0026#34;en\u0026#34; title = \u0026#34;FOTH0626\u0026#34; defaultContentLanguage = \u0026#34;en\u0026#34; hasCJKLanguage = true [pagination] pagerSize = 20 #ignoreFiles = [ #\u0026#34;content/post/Templates/*\u0026#34; #] 我来解释一下我的更改\nbaseurl 应该被解析到个人的域名（即usrname.github.io） title 会成为你的名字 hasCJKLanguage 开启后会正确识别CJK字符，对于中文写作者来说必开 pagerSize 决定一页显示多少篇博文 ignoreFiles 是因为个人的写作软件设置，稍后解释。更新： Templates文件夹已更改到根目录，写作软件直接打开根目录而不是原先的 content 目录。另外需要额外在 .gitignore 文件中添加 .obsidian/和 Templates 目录 个人信息（左栏） 在menu.toml 中更改如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 [[social]] identifier = \u0026#34;github\u0026#34; name = \u0026#34;GitHub\u0026#34; url = \u0026#34;https://github.com/FOTH0626\u0026#34; [social.params] icon = \u0026#34;brand-github\u0026#34; [[social]] identifier = \u0026#34;bilibili\u0026#34; name = \u0026#34;Bilibili\u0026#34; url = \u0026#34;https://space.bilibili.com/351177307\u0026#34; [social.params] icon = \u0026#34;brand-bilibili\u0026#34; [[social]] identifier = \u0026#34;mail\u0026#34; name = \u0026#34;Gmail\u0026#34; url = \u0026#34;mailto:fothli0626@gmail.com\u0026#34; [social.params] icon = \u0026#34;mail\u0026#34; identifier为唯一标识符 name为网页中图标名称 url 表示图标应该解析到的位置 icon 代表图标，本人从tabler寻找icon后复制到本地的asset/icons 文件夹下，这是默认的icon查找位置，需要名称与文件名对应。 在params.toml 更改如下\n1 2 3 4 5 6 7 8 9 favicon = \u0026#34;/heart-code.png\u0026#34; subtitle = \u0026#34;小小的人偶，想要摘月亮\u0026#34; [sidebar.avatar] src = \u0026#34;img/foth.jpg\u0026#34; [comments] enabled = false 将网页的标签页icon更改，默认目录为root/static 更改个人签名（来自Mygo二创十万客服） 更改个人头像（本人多个平台同头像，头像来自于本人非常喜欢的东方up主kk的一篇专栏中东方颜百选的预览图） 关闭评论功能（虽然本来就没有配置，但是最底下有评论系统会导致不必要的误解，而且看了不爽），可能在不久的未来配置（大概率参考此篇博客）(2024.11.19 更新，已开启评论功能) params.toml 新更改 1 2 3 4 5 6 7 8 [comments.waline] serverURL = \u0026#34;https://comment.foth.top\u0026#34; lang = \u0026#34;zh-CN\u0026#34; visitor = \u0026#34;Anonymous\u0026#34; avatar = \u0026#34;\u0026#34; emoji = [] requiredMeta = [\u0026#34;name\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;url\u0026#34;] placeholder = \u0026#34;leave a comment\u0026#34; 更改网页逻辑 permalinks.toml\n1 post = \u0026#34;/article/:slug/\u0026#34; 文章的url会被创建为/article/name，更好区分\n文章目录设置 1 2 3 4 [tableOfContents] endLevel = 5 ordered = false startLevel = 1 现在目录会显示为从一级标题到五级标题的无序列表排列\n写作环境 我在之前提到关于这个设置是因为本人的写作软件的问题\n1 2 3 ignoreFiles = [ \u0026#34;content/post/Templates/*\u0026#34; ] 现在我来详细解释，本人的写作软件为Obsidian，它有许多的插件，而我选择了一个名为Templater的插件用来快捷生成满足hugo前置格式的markdown文章，它本身需要一个模板但是模板文章明显不可以作为博客，所以我选择无视这个文件。我的模板如下\n1 2 3 4 5 6 7 8 9 10 11 --- title: \u0026#34;\u0026#34; description: \u0026#34;\u0026#34; slug: \u0026#34;\u0026#34; date: \u0026lt;% tp.date.now(\u0026#34;YYYY-MM-DD HH:mm:ss\u0026#34;) %\u0026gt; image: categories: tags: weight: 0 --- 最有效的是它会记录下我的博客文件创建日期，而且我可以在软件通过下拉框选择文件与tag，而不需要手动输入。\n更新 ：现在date为 \u0026lt;% tp.date.now(\u0026quot;YYYY-MM-DD HH:mm:ss+08:00\u0026quot;) %\u0026gt; 对齐 UTC + 8 时区。\n个人域名，CNAME与DNS 个人域名 个人域名购买自Namesilo，一年续费五六刀，相当便宜。 在githubpages设置中添加cname即可正确解析到foth0626.github.io。\nDNS还没配，等待后续更新。\nDNS解析 DNS 白嫖 Vercel 的服务，推荐使用github注册并登陆，这样可以直接链接到个人仓库。Import来自Github的仓库时，会让你选择模板部署，这时候选择 Hugo 模板不能正确解析！\n在push到github时，github workflow已经根据模板生成了静态网页，所以这时候应该在 Vercel 的 Setting -\u0026gt; Git -\u0026gt; Production Branch 中，选择 gh-pages 分支，模板选择Other 直接部署静态网页。 然后开始部署DNS， 我们进入 Namesilo 管理域名 添加DNS解析记录。\nHOSTNAME TYPE ADDRESS / VALUE A 76.223.126.88 comment CNAME cname-china.vercel-dns.com www CNAME cname-china.vercel-dns.com comment 的CNAME解析是因为评论系统 更改Namesilo的 NameServer Manager 为 ns1.vercel-dns.com 和 ns2.vercel-dns.com 。\n然后在Vercel的Settings -\u0026gt; Domains 添加两条记录 www.foth.top 和 foth.top 。其中 和 foth.top 指向了 www.foth.top 。\n这时候基本部署完成。在workflow推送后，Vercel会自动解析并部署。\n评论系统 评论系统选择 对于静态博客的评论系统，有许多可选的服务。stack主题本身也原生支持一些评论系统，见这个网址。一开始我跟随这篇教程：从零开始搭建你的免费博客评论系统（Remark42 + fly.io)。选择了相同的部署方案，基于go的开发环境+SQLite单文件的解决方案非常优雅，不过遇到一个始料未及的问题：我没有一张多币种的信用卡，无法在fly.io进行验证。\nWaline 部署 最终切换到Waline评论系统，直接跟随官方的快速上手教程。在Leancloud部署数据库，再把key 传入Vercel的环境变量。\n再前往域名服务商，添加一个CNAME comment.foth.top ，并填入Vercel的域名。\nMath 与 Waline冲突问题 然后又遇到一个很离谱的问题：Stack主题最新的release的数学公式渲染支持与Waline冲突，发现也有人遇到这个问题，见这个Issue关于最新版与Waline评论冲突问题 #1044。虽然通过关闭数学公式渲染可以暂缓这个问题，但是我的一些文章有不少公式，于是拷打GPT后得到一个暂时的解决方案。 首先在 go.mod 文件修改依赖关系为\n1 2 3 4 module github.com/CaiJimmy/hugo-theme-stack-starter go 1.17 require github.com/CaiJimmy/hugo-theme-stack/v3 v3.29.0 // indirect replace github.com/CaiJimmy/hugo-theme-stack/v3 =\u0026gt; ./theme/hugo-theme-stack 将原主题clone到本地对应路径，然后修改 waline.html 为\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { setTimeout(() =\u0026gt; { const walineContainer = document.querySelector(\u0026#39;#waline\u0026#39;); if (walineContainer) { Waline.init({{ $config | jsonify | safeJS }}); } else { console.error(\u0026#34;Waline container not found. Make sure the element with ID \u0026#39;waline\u0026#39; exists.\u0026#34;); } }, 500); // Delay 500ms to load waline comments. }); \u0026lt;/script\u0026gt; {{- end -}} 通过一个500ms的延迟加载解决。\n修改github workflow 将 Github Action 的 deploy Workflow ，从clone原作者的仓库更改为clone 自己的fork。\n1 2 3 steps: - name: Clone Hugo theme run: git clone https://github.com/FOTH0626/hugo-theme-stack.git themes/hugo-theme-stack 此外，把workflow 的update theme 修改为每月执行一次。（这事实上是不对的，问题并没有解决，在下次执行workflow时，github 依然会从原仓库clone后进行，每次执行工作流仍然会导致执行失败，不过可以把它当作每月提醒自己去检查原主题的更新情况。）\nClustr Map 访客热力图。 浏览到博客 【Blog怎么玩】学长教你用ClustrMaps定制全球用户访问地图添加访客热力图（如果访客过多超过免费额度会考虑删除功能。） 前往 www.clustrmaps.com 注册登录，输入自己的网站域名，复制widget代码添加到 本地的 ./themes/hugo-theme-stack/layouts/baseof.html 在 \u0026lt;head\u0026gt; 标签里插入代码，形式如下\n1 2 3 4 5 6 7 8 9 \u0026lt;head\u0026gt; {{- partial \u0026#34;head/head.html\u0026#34; . -}} {{- block \u0026#34;head\u0026#34; . -}}{{ end }} \u0026lt;script type=\u0026#34;text/javascript\u0026#34; id=\u0026#34;clustrmaps\u0026#34; src=\u0026#34;//clustrmaps.com/map_v2.js?d= YOUR_KEY \u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head ","date":"2024-09-24T00:00:00Z","image":"https://foth0626.github.io/article/build-my-blog/cover_hu_a4071b41dadc4476.jpg","permalink":"https://foth0626.github.io/article/build-my-blog/","title":"GithubPages + Hugo 搭建博客"}]